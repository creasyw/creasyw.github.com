
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Qiong Wu</title>
  <meta name="author" content="Qiong Wu">

  
  <meta name="description" content="Rank 1:SIGCOMM: ACM Conf on Comm Architectures, Protocols &amp; AppsINFOCOM: Annual Joint Conf IEEE Comp &amp; Comm SocSPAA: Symp on Parallel Algms &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://creasyw.github.io/blog/page/9/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <!-- add Mathjex.js by qiong -->
  <script src="http://kramdown.rubyforge.org/MathJax/MathJax.js" type="text/javascript"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="./atom.xml" rel="alternate" title="Qiong Wu" type="application/atom+xml">
  
  <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  
  
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Qiong Wu</a></h1>
  <!--
  
    <h2>A blogging framework for hackers.</h2>
  
  -->
</hgroup>
</header>
  <nav role="navigation"><!--
<ul class="subscription" data-subscription="rss">
  <li><a href="./atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:creasyw.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

-->

<ul class="main-navigation">
  <!--<li><a class="yellow" href="/">Hello</a></li>-->
  <li><a class="github" href="/blog/archives/">Blog</a></li>
  <li><a class="github" href="/tags">Tags</a></li>
  <li><a class="github" href="http://www.github.com/creasyw">Github</a></li>
  <li><a class="github" href="https://twitter.com/creasywuqiong">Twitter</a></li>
  <li><a class="github" href="/rss">RSS</a></li>
</ul>


</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/29/cs-conference-rankings-system/">CS Conference Rankings: System Technology Area</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-29T00:00:00-05:00" pubdate data-updated="true">Oct 29<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
Rank 1:<p>SIGCOMM: ACM Conf on Comm Architectures, Protocols &amp; Apps<br />INFOCOM: Annual Joint Conf IEEE Comp &amp; Comm Soc<br />SPAA: Symp on Parallel Algms and Architecture<br />PODC: ACM Symp on Principles of Distributed Computing<br />PPoPP: Principles and Practice of Parallel Programming<br />RTSS: Real Time Systems Symp<br />SOSP: ACM SIGOPS Symp on OS Principles<br />SOSDI: Usenix Symp on OS Design and Implementation<br />CCS: ACM Conf on Comp and Communications Security<br />IEEE Symposium on Security and Privacy<br />MOBICOM: ACM Intl Conf on Mobile Computing and Networking<br />USENIX Conf on Internet Tech and Sys<br />ICNP: Intl Conf on Network Protocols<br />PACT: Intl Conf on Parallel Arch and Compil Tech<br />RTAS: IEEE Real-Time and Embedded Technology and Applications Symposium<br />ICDCS: IEEE Intl Conf on Distributed Comp Systems<p><br />Rank 2:<p>CC: Compiler Construction<br />IPDPS: Intl Parallel and Dist Processing Symp<br />IC3N: Intl Conf on Comp Comm and Networks<br />ICPP: Intl Conf on Parallel Processing<br />SRDS: Symp on Reliable Distributed Systems<br />MPPOI: Massively Par Proc Using Opt Interconns<br />ASAP: Intl Conf on Apps for Specific Array Processors<br />Euro-Par: European Conf. on Parallel Computing<br />Fast Software Encryption<br />Usenix Security Symposium<br />European Symposium on Research in Computer Security<br />WCW: Web Caching Workshop<br />LCN: IEEE Annual Conference on Local Computer Networks<br />IPCCC: IEEE Intl Phoenix Conf on Comp &amp; Communications<br />CCC: Cluster Computing Conference<br />ICC: Intl Conf on Comm<br />WCNC: IEEE Wireless Communications and Networking Conference<br />CSFW: IEEE Computer Security Foundations Workshop<p><br />Rank 3:<p>MPCS: Intl. Conf. on Massively Parallel Computing Systems<br />GLOBECOM: Global Comm<br />ICCC: Intl Conf on Comp Communication<br />NOMS: IEEE Network Operations and Management Symp<br />CONPAR: Intl Conf on Vector and Parallel Processing<br />VAPP: Vector and Parallel Processing<br />ICPADS: Intl Conf. on Parallel and Distributed Systems<br />Public Key Cryptosystems<br />Annual Workshop on Selected Areas in Cryptography<br />Australasia Conference on Information Security and Privacy<br />Int. Conf on Inofrm and Comm. Security<br />Financial Cryptography<br />Workshop on Information Hiding<br />Smart Card Research and Advanced Application Conference<br />ICON: Intl Conf on Networks<br />NCC: Nat Conf Comm<br />IN: IEEE Intell Network Workshop<br />Softcomm: Conf on Software in Tcomms and Comp Networks<br />INET: Internet Society Conf<br />Workshop on Security and Privacy in E-commerce<p><br />Un-ranked:<p><br />PARCO: Parallel Computing<br />SE: Intl Conf on Systems Engineering (**)<br />PDSECA: workshop on Parallel and Distributed Scientific and<br />Engineering Computing with Applications<br />CACS: Computer Audit, Control and Security Conference<br />SREIS: Symposium on Requirements Engineering for Information Security<br />SAFECOMP: International Conference on Computer Safety, Reliability and Security<br />IREJVM: Workshop on Intermediate Representation Engineering for the<br />Java Virtual Machine<br />EC: ACM Conference on Electronic Commerce<br />EWSPT: European Workshop on Software Process Technology<br />HotOS: Workshop on Hot Topics in Operating Systems<br />HPTS: High Performance Transaction Systems<br />Hybrid Systems<br />ICEIS: International Conference on Enterprise Information Systems<br />IOPADS: I/O in Parallel and Distributed Systems<br />IRREGULAR: Workshop on Parallel Algorithms for Irregularly Structured Problems<br />KiVS: Kommunikation in Verteilten Systemen<br />LCR: Languages, Compilers, and Run-Time Systems for Scalable Computers<br />MCS: Multiple Classifier Systems<br />MSS: Symposium on Mass Storage Systems<br />NGITS: Next Generation Information Technologies and Systems<br />OOIS: Object Oriented Information Systems<br />SCM: System Configuration Management<br />Security Protocols Workshop<br />SIGOPS European Workshop<br />SPDP: Symposium on Parallel and Distributed Processing<br />TreDS: Trends in Distributed Systems<br />USENIX Technical Conference<br />VISUAL: Visual Information and Information Systems<br />FoDS: Foundations of Distributed Systems: Design and Verification of<br />Protocols conference<br />RV: Post-CAV Workshop on Runtime Verification<br />ICAIS: International ICSC-NAISO Congress on Autonomous Intelligent Systems<br />ITiCSE: Conference on Integrating Technology into Computer Science Education<br />CSCS: CyberSystems and Computer Science Conference<br />AUIC: Australasian User Interface Conference<br />ITI: Meeting of Researchers in Computer Science, Information Systems<br />Research &amp; Statistics<br />European Conference on Parallel Processing<br />RODLICS: Wses International Conference on Robotics, Distance Learning<br />&amp; Intelligent Communication Systems<br />International Conference On Multimedia, Internet &amp; Video Technologies<br />PaCT: Parallel Computing Technologies workshop<br />PPAM: International Conference on Parallel Processing and Applied Mathematics<br />International Conference On Information Networks, Systems And Technologies<br />AmiRE: Conference on Autonomous Minirobots for Research and Edutainment<br />DSN: The International Conference on Dependable Systems and Networks<br />IHW: Information Hiding Workshop<br />GTVMT: International Workshop on Graph Transformation and Visual<br />Modeling Techniques</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/29/backup-interview-summary/">Backup: Interview Summary</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-29T00:00:00-05:00" pubdate data-updated="true">Oct 29<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
谷歌笔试：<br />1.<br />n支队伍比赛，分别编号为0，1，2。。。。n-1，已知它们之间的实力对比关系，存储在一个二维数组w[n][n] 中，w[i][j]<br />的值代表编号为i，j的队伍中更强的一支 所以w[i][j]=i 或者j，现在给出它们的出场顺序，并存储在数组order[n]中，<br />比如order[n] = {4,3,5,8,1&#8230;&#8230;}，那么第一轮比赛就是 4对3， 5对8。。。。。。<br />胜者晋级，败者淘汰，同一轮淘汰的所有队伍排名不再细分，即可以随便排，<br />下一轮由上一轮的胜者按照顺序，再依次两两比，比如可能是4对5,直至出现第一名<br />编程实现，给出二维数组w，一维数组order 和 用于输出比赛名次的数组result[n]，求出result<p><br />2.题目说的比较花哨，根据我的理解，本质上就是有n个长为m+1的字符串，如果某个字符串的最后m个字符与某个字符串的前m个字符匹配，则两个字符串可以联接，问这n个字符串最多可以连成一个多长的字符串，如果出现循环，则返回错误<p>百度面试：<p>3.<br />用天平（只能比较，不能称重）从一堆小球中找出其中唯一一个较轻的，使用x次天平 最多可以从y个小球中找出较轻的那个，求y与x的关系式<br />4.有一个很大很大的输入流，大到没有存储器可以将其存储下来，而且只输入一次，如何从这个输入流中随机取得m个记录<br />5.大量的URL字符串，如何从中去除重复的，优化时间空间复杂度<p>网易有道笔试：<br />6. 求一个二叉树中任意两个节点间的最大距离，两个节点的距离的定义是<br />这两个节点间边的个数，比如某个孩子节点和父节点间的距离是1，和相邻兄弟节点间的距离是2，优化时间空间复杂度<br />7.求一个有向连通图的割点，割点的定义是，如果除去此节点和与其相关的边，有向图不再连通，描述算法<p>discussion can be found @:<br /><a href="http://topic.csdn.net/u/20100930/13/9f10c56c-9545-488e-9b53-edffc9b6761d.html">http://topic.csdn.net/u/20100930/13/9f10c56c-9545-488e-9b53-edffc9b6761d.html</a><p>==========<p>GOOGLE今天晚上的笔试题，刚参加回来.<p>第一题比较简单，检测同一个平面上的两个矩形是否重合<p>第二题是，给定一个随机函数，对一个数组进行随机排列，保证所有可能的排列出现的概率相等，也就是n!分之一<p><br />第三题就是约瑟夫问题的最优解法~Knuth具体数学上有，不过我忘记了，自己没推导出来，就写了个模拟<p>discussion can be found @:<br /><a href="http://topic.csdn.net/u/20101018/23/75b6dc53-610f-401e-b8ae-5aebee5cabe8.html">http://topic.csdn.net/u/20101018/23/75b6dc53-610f-401e-b8ae-5aebee5cabe8.html</a><p>==========<p>雅虎：<br />1.对于一个整数矩阵，存在一种运算，对矩阵中任意元素加一时，需要其相邻（上下左右）某一个元素也加一，现给出一正数矩阵，判断其是否能够由一个全零矩阵经过上述运算得到。<p>2.一个整数数组，长度为n，将其分为m份，使各份的和相等，求m的最大值<br />比如{3，2，4，3，6} 可以分成{3，2，4，3，6} m=1;<br />{3,6}{2,4,3} m=2<br />{3,3}{2,4}{6} m=3 所以m的最大值为3<p>搜狐：<p>3.四对括号可以有多少种匹配排列方式？比如两对括号可以有两种：（）（）和（（））<p>创新工场：<p>4.求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}<p>微软：<br />5.一个数组是由一个递减数列左移若干位形成的，比如{4，3，2，1，6，5}是由{6，5，4，3，2，1}左移两位形成的，在这种数组中查找某一个数。<p>discussion can be found @:<br /><a href="http://topic.csdn.net/u/20101021/14/7fdbcd52-3ee6-42ce-b48e-8fb56c4418da.html">http://topic.csdn.net/u/20101021/14/7fdbcd52-3ee6-42ce-b48e-8fb56c4418da.html</a><p>==========<p>雅虎：<br />1.对于一个整数矩阵，存在一种运算，对矩阵中任意元素加一时，需要其相邻（上下左右）某一个元素也加一，现给出一正数矩阵，判断其是否能够由一个全零矩阵经过上述运算得到。<p>2.一个整数数组，长度为n，将其分为m份，使各份的和相等，求m的最大值<br />比如{3，2，4，3，6} 可以分成{3，2，4，3，6} m=1;<br />{3,6}{2,4,3} m=2<br />{3,3}{2,4}{6} m=3 所以m的最大值为3<p>搜狐：<p>3.四对括号可以有多少种匹配排列方式？比如两对括号可以有两种：（）（）和（（））<p>创新工场：<p>4.求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}<p>微软：<br />5.一个数组是由一个递减数列左移若干位形成的，比如{4，3，2，1，6，5}是由{6，5，4，3，2，1}左移两位形成的，在这种数组中查找某一个数。<p>discussion can be found @:<br /><a href="http://topic.csdn.net/u/20101021/14/7fdbcd52-3ee6-42ce-b48e-8fb56c4418da.html">http://topic.csdn.net/u/20101021/14/7fdbcd52-3ee6-42ce-b48e-8fb56c4418da.html</a></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/22/zt-unix-vs-windows/">(ZT) Unix vs. Windows</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-22T00:00:00-05:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
我看UNIX与Windows的本质区别<br /><br />文化，我首先想到的是文化。Unix和Windows从诞生之初的文化差异本质上划分了两者的界限。直观看来，一个装逼文化，一个傻逼文化。<br /><br />Unix诞生在贝尔实验室的MULTICS项目之后。据说当时这个项目设计得十分复杂，功能设计也几乎是上天入地无所不能。虽说当时贝尔实验室是很牛，可以牛到不用装逼也能露逼一下的地步。但历史告诉我们这种项目最后绝对会死得很惨。当然，项目最终结果还是没有违背历史规律。当时一位MULTICS参与者Ken Thompson事后痛定思痛，准备重新自己开发一个多任务操作系统，摒弃了MULTICS过于复杂的系统设计，力求新系统的简洁紧凑。传闻时值Ken Thompson老婆带上孩子回娘家过日子去了，一时间Ken Thompson晚上无以为乐，只好天天以堆码为业。不到一个月，Ken Thompson用汇编把这套操作系统编写出来了，这就是后来流芳百世的UNIX。当然，当时的Ken Thompson根本没有意会到他这个业余时间的作品会改变整个计算机发展史。因此这个操作系统设计用户群只针对他预想的计算机科学家、黑客，再不济怎么也得算上个计算机科学技术本科生。Unix只面对政府、研究机构、大学等专业性很强的机构，简洁、高效、安全是Unix的文化哲学。同时结合到当时的硬件条件限制，也不难理解UNIX诞生之初就根深蒂固的文化：<br /><br />1、计算机庞大的占地面积、高额的购买维护费用使得普通用户根本无力支撑起一台计算机的各种资源消耗，当时更多的是计算机专家在通过终端在控制整个计算机运作逻辑。没有GUI、没有多媒体，字符界面，这对于这批靠计算机完成科学任务的黑客来说已经完全够用了。<br /><br />2、同时遵循简洁统一的输入输出接口，相比于GUI的事件驱动模型来说，更适合使用脚本将各种程序粘合起来，完成复杂多样的计算任务。<br /><br />有人说起过UNIX正巧在当年GUI史前诞生，时运不济，所以只出了个字符怪胎，要是再踌躇几年，等到GUI日臻成熟，那诞生出的UNIX恐怕就是如今Windows的翻版了。对此我还是不太认可，UNIX的存在是计算机荒洪时代遗留的文化，即使现在丰富多彩的GUI也照样没有改变UNIX的基础设计恐怕就是一个极好的证据。目前大多数的服务器依然保持着当年UNIX诞生之初的风貌，依然CLI、依然Shell，因为我们需要把更多的资源让给使用服务器的客户，人类对计算机性能的榨取永远是贪婪的。这让我想起了几年前Windows渐入佳境PC，游戏刚大行其道，桌面游戏编写还不是那么方便时候，有人预言等几年之后，按照摩尔定律，编写星际争霸之类的游戏便不需要多牛逼的算法，甚至能用写脚本语言都能完成。这几年算是大致差不多算过来了吧，星际是有牛人用JavaScript完成了，不过现时最牛逼的游戏(如魔兽世界)还是会用很牛逼的算法，还是需要使用C/C++，还是需要精通图形学，还是需要熟悉图形硬件。所以不管硬件如何发展，UNIX文化中的简洁高效这些准则还是依然存在，因为我们会把最佳的性能留给我们服务器的客户，然后可以把敲打字符，玩弄指法的时间留给自己，在老板面前装逼一下。<br /><br />Windows(以及其前任DOS)诞生在公司，公司不像学院，不会像UNIX一样如果能装逼就尽量装逼一下，公司直接面对客户，产品唯一使命就是取悦用户，只能把用户伺候好了，公司才能维系发展。所以Windows诞生之初就一直肩负比尔&#8221;让每一个家庭都有一台电脑&#8221;的使命，不装逼，不玩酷，一切功能照顾用户，就是用户是傻逼你也得当亲爹一样伺候。故而Windows一直就假定使用它的用户你就是一个傻逼，哪怕是删除文件这个小问题上，Windows也会想小娘们儿一样谨谨慎慎战战兢兢地一再向人确认&quot;确实要删除****吗？&quot;&quot;确实要删除只读文件****吗?&quot;。当然，最终能够让大妈大叔阿公阿婆阿猫阿狗都能使用上计算机的Windows绝对占领了终端用户桌面，比尔也因此一夜暴富，摇身一变成为世界首富&amp;慈善家。不得不承认，如果没有Windows，&quot;让每一个家庭都有一台电脑&quot;的崇高理想恐怕又得推迟几年才能够得以实现了。自然，微软技术是肯定不差的，而不是像一些Linux小菜鸟口中所言&quot;微软技术很烂&quot;，相反微软技术是很牛的，牛到曾经豪言可以立马灭掉Google，试看如今还有谁可以发出这样傻逼的豪言。但是微软牛，不代表Windows就可以干过MULTICS，上天入地翻江倒海无所不能。Windows 在安全性、性能以及开源项目上与UNIX相比确实还是有一定差距，但这并不妨碍windows成为桌面第一大操作系统。<br /><br />UNIX的黑客们，眼见着曾经引以为豪的计算机技术壁垒瞬间被Windows GUI冲击到荡然无存了，心中肯定是有落差的。不过这段技术演变技术普及已经成为了历史发展趋势。一个少数人才能驾驭的技术，哪怕就是敲一个ls这样简单的命令，你也可以把它吹破牛皮，扯虎皮拉大旗捧为艺术珍品，搞得善男甚广善女甚众。一旦技术被迫普及后，曾经视作的艺术瞬间就被廉价的工业化大生产所替代，现在满大街的廉价代码工就是计算机程序设计工业化后的结果。前段时间众人大骂Java程序员把自己的价位又拉低了。殊不知，拉低自己价位的非Java也，乃工业化大生产趋势。今不出Java，明儿准会出来个Bava，Cava，照样把你收拾成码农。时至如今，UNIX黑客们还在装逼，用CLI命令行跑出花花绿绿的文字，时不时感叹下曾经的软件英雄时代一去不复返，时不时像祥林嫂一般唠叨&quot;当年哥可是写汇编的，没想到如今沦落到如此地步，人心不古，世风日下啊~&quot;，时不时还顾影自怜，想装逼下，可惜时光不再。<br /><br />妈逼的给老子回去写代码！这个月还想不想领工资了！？<br /><br /><br />结语：<br /><br />不管是UNIX的装逼文化，还是Windows的傻逼文化，最终在计算机产业工业化的历史滚滚长流中归于平庸，归于廉价。曾经的那批牛逼的、不牛逼的、风骚的、不风骚的UNIX文化精英们，如今早已是廉颇老矣，尚可喝粥。曾经被意淫为&quot;计算机科学与艺术&quot;如今也早已沦落为&quot;软件码工&quot;。软件英雄时代早已不再，编码也成为三百六十行中的一行，一种用以谋生的手段，一种混饭吃的活路。关键问题早已不在程序，不在编码：<br /><br /><b>编程只是一个工具，关键在于你拿这个工具来实现别人的事业，还是自己的事业。</b></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/22/basic-python-math-calculation-in/">Basic Python Math Calculation in Gnuradio</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-22T00:00:00-05:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
/gnuradio3.2.2/gr-wxgui/src/python/common.py<p>####################<br /># Shared Functions<br />#####################<br />import numpy<br />import math<p>&quot;&quot;&quot;<br /># Python is a general purpose programming language.<br />It is interpreted and dynamically typed and is very<br />suited for interactive work and quick prototyping,<br />while being powerful enough to write large applications in.<br /># NumPy is a Python extension module, written mostly in C,<br />that defines the numerical array and matrix types<br />and basic operations on them.<br />&quot;&quot;&quot;<p>def get_exp(num):<br />&quot;&quot;&quot;<br />Get the exponent of the number in base 10.<br />@param num the floating point number<br />@return the exponent as an integer<br />&quot;&quot;&quot;<br />if num == 0: return 0<br />return int(math.floor(math.log10(abs(num))))<p>def get_clean_num(num):<br />&quot;&quot;&quot;<br />Get the closest clean number match to num with bases 1, 2, 5.<br />@param num the number<br />@return the closest number<br />&quot;&quot;&quot;<br />if num == 0: return 0<br />sign = num &gt; 0 and 1 or -1<br />exp = get_exp(num)<br />nums = numpy.array((1, 2, 5, 10))*(10**exp)<br />return sign*nums[numpy.argmin(numpy.abs(nums - abs(num)))]<br />#numpy.argmin: Return the indices of the minimum values along an axis.<p>def get_clean_incr(num):<br />&quot;&quot;&quot;<br />Get the next higher clean number with bases 1, 2, 5.<br />@param num the number<br />@return the next higher number<br />&quot;&quot;&quot;<br />num = get_clean_num(num)<br />exp = get_exp(num)<br />coeff = int(round(num/10**exp))<br />return {<br />-5: -2,<br />-2: -1,<br />-1: -.5,<br />1: 2,<br />2: 5,<br />5: 10,<br />}[coeff]*(10**exp)<p>def get_clean_decr(num):<br />&quot;&quot;&quot;<br />Get the next lower clean number with bases 1, 2, 5.<br />@param num the number<br />@return the next lower number<br />&quot;&quot;&quot;<br />num = get_clean_num(num)<br />exp = get_exp(num)<br />coeff = int(round(num/10**exp))<br />return {<br />-5: -10,<br />-2: -5,<br />-1: -2,<br />1: .5,<br />2: 1,<br />5: 2,<br />}[coeff]*(10**exp)<p>def get_min_max(samples):<br />&quot;&quot;&quot;<br />Get the minimum and maximum bounds for an array of samples.<br />@param samples the array of real values<br />@return a tuple of min, max<br />&quot;&quot;&quot;<br />scale_factor = 3<br />mean = numpy.average(samples)<br />rms = numpy.max([scale_factor*((numpy.sum((samples-mean)**2)/len(samples))**.5),<br />.1])<br />min = mean - rms<br />max = mean + rms<br />return min, max</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/21/some-commands-for-matlab/">Some Commands for Matlab</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-21T00:00:00-05:00" pubdate data-updated="true">Oct 21<span>st</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
matrix functions<br /><br /><b>&nbsp;INV</b>&nbsp;&nbsp;&nbsp; Matrix inverse.<br />&nbsp;&nbsp;&nbsp; INV(X) is the inverse of the square matrix X.<br />&nbsp;&nbsp;&nbsp; A warning message is printed if X is badly scaled or<br />&nbsp;&nbsp;&nbsp; nearly singular.<br /><br /><b>&nbsp;.&#8217; Transpose.</b><br />&nbsp;&nbsp;&nbsp; X.&#8217; is the non-conjugate transpose.<br />&nbsp;&nbsp;&nbsp; B = TRANSPOSE(A) is called for the syntax A.&#8217; when A is an object.<br /><br /><b>&nbsp;SQUEEZE</b> Remove singleton dimensions.<br />&nbsp;&nbsp;&nbsp; B = SQUEEZE(A) returns an array B with the same elements as<br />&nbsp;&nbsp;&nbsp; A but with all the singleton dimensions removed.&nbsp; A singleton<br />&nbsp;&nbsp;&nbsp; is a dimension such that size(A,dim)==1.&nbsp; 2-D arrays are<br />&nbsp;&nbsp;&nbsp; unaffected by squeeze so that row vectors remain rows.<br />&nbsp;&nbsp;&nbsp; For example,&nbsp;&nbsp; squeeze(rand(2,1,3))&nbsp;&nbsp;&nbsp; is 2-by-3.<br /><br />Especially, for a 3-dimension matrix, for the command &#8220;matri = original_matrix(1,:,:)&#8221;, the resulting matrix matri is still a 3-D matrix whose 1st dimension is just 1.<br /><br />==========<br /><br />for plotting, this example will explain the most frequently used commands:<br /><br />x = -pi:.1:pi;<br />y = sin(x);<br />plot(x,y);<br />set(gca,&#8217;XTick&#8217;,-pi:pi/2:pi);<br />set(gca,&#8217;XTickLabel&#8217;,{&#8216;-pi&#8217;,&#8217;-pi/2&#8217;,&#8217;0&#8217;,&#8217;pi/2&#8217;,&#8217;pi&#8217;});<br />xlabel(&#8216;-\pi \leq \Theta \leq \pi&#8217;);<br />ylabel(&#8216;sin(\Theta)&#8217;);<br />title(&#8216;Plot of sin(\Theta)&#8217;);<br />AXIS([XMIN XMAX YMIN YMAX])<br />XLIM([XMIN XMAX])<br />YLIM([YMIN YMAX])</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/18/some-usrpspectrumsensepy-code/">Some usrp_spectrum_sense.py Code Explanation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-18T00:00:00-05:00" pubdate data-updated="true">Oct 18<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
Hi Everybody,<br /><br />and Merry Christmas<br /><br />I received many emails requesting some explanation for usrp_spectrum_sense.py gnuradio example program. The following link contains the code with some explanation and one bug fix (in self.max_center_freq equation):<br /><br /><a href="http://rapidshare.com/files/177960860/usrp_spectrum_sense.py">http://rapidshare.com/files/177960860/usrp_spectrum_sense.py</a><br /><br /><br /><br /><br /><br />usrp_spectrum_sense.py Explanation :<br />=======================================================================================<br /><br />Introduction:<br />&#8212;&#8212;&#8212;&#8212;-<br /><br />1) This program can be used as a basic code for implementing wideband spectrum analyzer.<br />2) As we know, the USRP cannot examine more than 8 MHz of RF spectrum due to USB bus limitations.<br />3) So, to scan across a wide RF spectrum band (bigger than 8 MHz) we have to tune USRP RF front end in suitable steps so that we can examine a lot of spectrum, although not all at the same instant.<br />4) The usrp_spectrum_sense shows the way how it can be done.It steps across the spectrum and make the RF measurements. This application can<br />sense a large bandwidth, but not in real time, and it can do the frequency sweep over the required frequency range,<br /><br /><br /><br />Theory:<br />&#8212;&#8212;-<br /><br />1) To use N points complex FFT X(W) analysis, we have to get N time samples x(t) which are sampled at Fs.<br />2) These N time samples must be time windowed using a known window function to reduce spectral leakage.<br />3) Performing N points complex FFT analysis.<br />4) The output of the complex FFT will represent the frequency spectrum contents as follows:<br /><br />a) The first value of the FFT output (bin 0 == X[0]) is the passband center frequency.<br />b) The first half of the FFT (X[1] to X[N/2-1] contains the positive baseband frequencies,which corresponds to the passband spectrum from the center frequency out to the maximum passband frequency (from center frequency to +Fs/2).<br />c) The second half of the FFT (X[N/2] to X[N-1]) contains the negative baseband frequencies,which correspond to the lowest passband frequency up to the passband center frequency (from -Fs/2 to center frequency).<br /><br /><br />Example<br />&#8212;&#8212;-<br /><br />Let us assume that we have 1024 (I and Q) samples gathered using a tuner centered at 20MHz. And let us assume that the sampling frequency was 8MHz.<br />Doing 1024 points complex FFT means:<br /><br />1) FFT Frequency resolution is : 8MHz / 1024 = 7812.5 KHz<br />2) The output of the FFT X[0] represents the spectrum at 20MHz.<br />3) The output of the FFT X[1] to X[511] represents the frequencies from 20.0078125 MHz to 23.9921875 MHz (about 4MHz above center frequency).<br />4) The output of the FFT X[512] to X[1023] represents the frequencies from 16.0078125 MHz to 19.9921875 MHz (about 4MHz bellow center frequency).<br /><br /><br /><br /><br />RF Frequency Sweeping<br />&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br /><br />1) Let us suppose that we want to scan RF spectrum band from 10MHz to 52 MHz.<br />2) Let us remember that USRP can analyze 8MHz of frequency at a time.<br />3) So theoretically we have to step our RF center frequency as follows:<br /><br />First step is 14MHz (it will cover frequency band from 10MHz to 18MHz),<br />Second step is 22MHz (it will cover frequency band from 18MHz to 26MHz),<br />Third step is 30MHz (it will cover frequency band from 26MHz to 34MHz),<br />Fourth step is 38MHz (it will cover frequency band from 34MHz to 42MHz),<br />Fifth step is 46MHz (it will cover frequency band from 42MHz to 50MHz),<br />and finally the Sixth step is 54MHz (it will cover frequency band from 50MHz to 58MHz). Remember that we want the frequencies up to 52MHz only, so we have to discard some FFT points from the Sixth analysis.<br /><br /><br />4) Paralytically we have to use FFT overlapping to reduce the non linearity response of the Digital Down Converter (the DDC frequency response is not Flat from -Fs/2 to + Fs/2) and to fill the frequency holes that will be present at the FFT analysis edges (10MHz, 18MHz, 26MHz, 34MHz, 42MHz, 50 MHz).<br /><br />So if we choose to use an overlap of 25%, this means that our step size will be 6MHz (8MHz*(1-.25)), thus practically we have to step our RF center frequency as follows:<br /><br />First step is 13MHz (it will cover frequency band from 9MHz to 17MHz),<br />Second step is 19MHz (it will cover frequency band from 15MHz to 23MHz),<br />Third step is 25MHz (it will cover frequency band from 21MHz to 29MHz),<br />Fourth step is 31MHz (it will cover frequency band from 27MHz to 35MHz),<br />Fifth step is 37MHz (it will cover frequency band from 33MHz to 41MHz),<br />Sixth step is 43MHz (it will cover frequency band from 39MHz to 47MHz),<br />and Finally the Seventh step is 49MHz (it will cover frequency band from 45MHz to 53MHz),<br /><br /><br /><br /><br /><br />Changing RF center Frequency<br />&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br /><br />1) To change USRP RF center frequency we have to send a tunning command to the USRP every time we complete the analysis of the current frequency chunk.<br />2) Before gnuradio revision [10165], all USRP RF daughterboards tunning were done using Python functions and classes. After that revision, tunning the USRP daughterboards from withen C++ code is possible.<br />3) In usrp_spectrum_sense.py, the DSP C++ written code is allowed to transparently invoke Python code USRP tune function. This tunning control is done in gr_bin_statistics_f sink function.<br /><br /><br /><br /><br />Tunning Delay Problem:<br />&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br /><br />When we command the usrp RF daughterboard to change its center frequency, we have to wait until (right) ADC samples arrive to our FFT engine and we have to insure that it belongs to the wanted center frequency. This represents a problem since there are many delays along the digitization path (RF synthesizer settling time, and pipeline propagation delay [FPGA FIFO filling time, USB transferring time&#8230;etc]). To overcome this problem we have to use enough tune delay time in order to  be sure that the samples entering our FFT block are belong to the requested center frequency. This is done simply by dropping the incoming received samples over a specified tunning delay time.<br /><br /><br /><br />usrp_spectrum_sense Implementation<br />&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br /><br />1) The engine of the usrp_spectrum_sense depends mainly on bin_statistics sink function.<br /><br />2) bin_statistics function combines statistics gathering with a state machine for controlling the USRP RF tuning (frequency sweeping). It determines max values (keeps track of the maximum power in each FFT bin) of vectors (with length vlen) over a time period determined by dwell_delay (after converting it to a number of FFT vectors). This operation is performed after discarding tune_delay samples.<br /><br />3) After processing N = dwell_delay samples, bin_statistics composes a message and inserts it in a message queue.<br /><br />4) Each message from bin_statistics consists of a vector of max values, prefixed by the center frequency corresponding to the associated samples,<br />i.e., it is the center frequency value of the delivered input samples to bin_statistics.<br /><br /><br /><br /><br />Choosing Tune and Dwell delay times<br />&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-<br /><br />1) We have to play with the &#8211;tune-delay and &#8211;dwell-delay command line options to determine appropriate timming values. The most important one is the tune delay time.<br /><br />2) The choose of tune-delay should include time for the front end PLL to settle, plus time for the new samples to propagate through the pipeline.  The default value is 1ms, which is probably in the ballpark on the RFX** boards.  The TV RX board is much slower.  The tuner data sheets says it could take 100ms to settle.<br /><br />3) The tune delay timing parameter passed to bin_statistics is calculated in FFT frames which depends on USRP rate and FFT length as in :<br /><br />tune_delay_passed_to_bin_statistics = int(round(required_tune_delay_in_sec*usrp_rate/fft_size))<br /><br />if this calculated value is less than &quot;1&quot;, then we should make it at least &quot;1&quot; FFT frame.<br /><br />For example:<br /><br />If the :<br /><br />required_tune_delay_in_sec = 10e-3<br />and usrp_rate = 8000000 (decimation =8)<br />and FFT size is 1024<br /><br /><br />Then :<br /><br />tune_delay_passed_to_bin_stats = 78   (FFT Frames)<br /><br />This means we have to skip 78 incoming vectors (FFT frames) before we actually use the acquired samples in our spectrum statistics.<br /><br />4) Beside tunning time depends on the hardware (RF synthesizer speed),one should remember that the time needed to collect 1024 samples<br />with decimation rate=8 (minimum USRP decimation) is 128 usec, while the time needed to collect 1024 samples with decimation rate=256 (maximum USRP decimation) is 4.096 msec. This means that the tune delay in the case of decimation rate =256 should be larger than that used for decimation = 8.<br /><br />5) A working tune delay value (which gives accurate results) can be known by experiments (for given decimation rate and FFT length).<br /><br /><br /><br /><br />Interrupting Output Spectrum<br />&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br /><br />The actual mapping from the levels at the daughterboard antenna input port to the output analysis values depends on a lot of factors including the used daughterboard RF gain and decimation specific gain in the digital down converter. You&#39;ll need to calibrate the system if you need something that maps to dBm.Currently, the output of usrp_spectrum_sense is the magnitude squared of the FFT output.  That is, for each FFT bin[i], the output is Y[i] = re[X[i]]*re[X[i]] + im[X[i]]*im[X[i]]. If you want power, take the square root of the output.<br /><br />========================================================================================<br /><br /><br />Best Regards,<br /><br /><br />Firas</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/18/advance-info-about-usrp-trans/">Advance Info. About Usrp Trans.</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-18T00:00:00-05:00" pubdate data-updated="true">Oct 18<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
new examples for the 802.11b trans. (<a href="https://www.cgran.org/browser/projects/bbn_80211/branches/douggeiger/src/examples?rev=113">here</a>)<br /><br />======================<br /><br />btw, there is an <a href="http://www.mail-archive.com/discuss-gnuradio@gnu.org/msg18734.html">excellent discussion</a> about how to run the code.<br /><br /><b><span style="font-size: large;">(1)</span></b><br /><pre>&nbsp;</pre><pre>Hi</pre><br />I am trying to establish communication between USRP2 and USRP1. I am using RFX2400 daughterboard. I am using Ubuntu 8.10. I am using the svn version of GNU Radio. I dont know the revision number. I am not able to receive anything on USRP2 when USRP1 is transmitting and vice versa. The python codes for USRP2 work perfectly fine. I guess there is some problem with the ADC and DAC incompatibility (interpolation and decimation) between USRP2 and USRP1. I am attaching all the necessary files that I am using currently. I would appreciate if someone can look at these files and help me to sort out the problem. &nbsp; </pre><br /><br /><pre>benchmark_tx.py
<br />
<br />#!/usr/bin/env python
<br />#
<br /># Copyright 2005, 2006, 2007 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />from gnuradio import gr, gru, modulation_utils
<br />from gnuradio import usrp2
<br />from gnuradio import eng_notation
<br />from gnuradio.eng_option import eng_option
<br />from optparse import OptionParser
<br />
<br />import random
<br />import time
<br />import struct
<br />import sys
<br />
<br /># from current dir
<br />from transmit_path_usrp2 import transmit_path
<br />import fusb_options
<br />
<br />#import os 
<br />#print os.getpid()
<br />#raw_input('Attach and press enter')
<br />
<br />class my_top_block(gr.top_block):
<br />    def __init__(self, modulator, options):
<br />        gr.top_block.__init__(self)
<br />        self.txpath = transmit_path(modulator, options)
<br />        self.connect(self.txpath)
<br />
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />#                                   main
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />
<br />def main():
<br />
<br />    def send_pkt(payload='', eof=False):
<br />        return tb.txpath.send_pkt(payload, eof)
<br />
<br />    def rx_callback(ok, payload):
<br />        print "ok = %r, payload = '%s'" % (ok, payload)
<br />
<br />    mods = modulation_utils.type_1_mods()
<br />
<br />    parser = OptionParser(option_class=eng_option,
<br />conflict_handler="resolve")
<br />    expert_grp = parser.add_option_group("Expert")
<br />
<br />    parser.add_option("-m", "--modulation", type="choice",
<br />choices=mods.keys(),
<br />                      default='gmsk',
<br />                      help="Select modulation from: %s [default=%%default]"
<br />                            % (', '.join(mods.keys()),))
<br />
<br />    parser.add_option("-s", "--size", type="eng_float", default=1500,
<br />                      help="set packet size [default=%default]")
<br />    parser.add_option("-M", "--megabytes", type="eng_float", default=1.0,
<br />                      help="set megabytes to transmit [default=%default]")
<br />    parser.add_option("","--discontinuous", action="store_true",
<br />default=False,
<br />                      help="enable discontinous transmission (bursts of 5
<br />packets)")
<br />    parser.add_option("","--from-file", default=None,
<br />                      help="use file for packet contents")
<br />
<br />    transmit_path.add_options(parser, expert_grp)
<br />
<br />    for mod in mods.values():
<br />        mod.add_options(expert_grp)
<br />
<br />    fusb_options.add_options(expert_grp)
<br />    (options, args) = parser.parse_args ()
<br />
<br />    if len(args) != 0:
<br />        parser.print_help()
<br />        sys.exit(1)
<br />
<br />    if options.tx_freq is None:
<br />        sys.stderr.write("You must specify -f FREQ or --freq FREQ\n")
<br />        parser.print_help(sys.stderr)
<br />        sys.exit(1)
<br />
<br />    if options.from_file is not None:
<br />        source_file = open(options.from_file, 'r')
<br />
<br />    # build the graph
<br />    tb = my_top_block(mods[options.modulation], options)
<br />
<br />    r = gr.enable_realtime_scheduling()
<br />    if r != gr.RT_OK:
<br />        print "Warning: failed to enable realtime scheduling"
<br />
<br />    tb.start()                       # start flow graph
<br />        
<br />    # generate and send packets
<br />    nbytes = int(1e6 * options.megabytes)
<br />    n = 0
<br />    pktno = 0
<br />    pkt_size = int(options.size)
<br />
<br />    while n &lt; nbytes:
<br />        if options.from_file is None:
<br />            data = (pkt_size - 2) * chr(pktno &amp; 0xff) 
<br />        else:
<br />            data = source_file.read(pkt_size - 2)
<br />            if data == '':
<br />                break;
<br />
<br />        payload = struct.pack('!H', pktno &amp; 0xffff) + data
<br />        send_pkt(payload)
<br />        n += len(payload)
<br />        sys.stderr.write('.')
<br />        if options.discontinuous and pktno % 5 == 4:
<br />            time.sleep(1)
<br />        pktno += 1
<br />        
<br />    send_pkt(eof=True)
<br />
<br />    tb.wait()                       # wait for it to finish
<br />
<br />if __name__ == '__main__':
<br />    try:
<br />        main()
<br />    except KeyboardInterrupt:
<br />        pass
<br />
<br />
<br />transmit_path_usrp2.py
<br />
<br />#
<br /># Copyright 2005,2006,2007 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />from gnuradio import gr, gru, blks2
<br />from gnuradio import usrp2
<br />from gnuradio import eng_notation
<br />
<br />import copy
<br />import sys
<br />
<br /># from current dir
<br />from pick_bitrate import pick_tx_bitrate
<br />
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />#                              transmit path
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />
<br />class transmit_path(gr.hier_block2): 
<br />    def __init__(self, modulator_class, options):
<br />        '''
<br />        See below for what options should hold
<br />        '''
<br />        gr.hier_block2.__init__(self, "transmit_path",
<br />                                gr.io_signature(0, 0, 0), # Input signature
<br />                                gr.io_signature(0, 0, 0)) # Output signature
<br />
<br />        options = copy.copy(options)    # make a copy so we can
<br />destructively modify
<br />
<br />        self._interface          = options.interface           # the USRP
<br />board attached
<br />        self._mac_addr           = options.mac_addr
<br />        self._verbose            = options.verbose
<br />        self._tx_freq            = options.tx_freq         # tranmitter's
<br />center frequency
<br />        self._tx_amplitude       = options.tx_amplitude    # digital
<br />amplitude sent to USRP
<br />        #self._tx_subdev_spec     = options.tx_subdev_spec  # daughterboard
<br />to use
<br />        self._bitrate            = options.bitrate         # desired bit
<br />rate
<br />        self._interp             = options.interp          # interpolating rate 
<br />for
<br />the USRP (prelim) 
<br />        self._samples_per_symbol = options.samples_per_symbol  # desired
<br />samples/baud 
<br />        #self._fusb_block_size    = options.fusb_block_size # usb info for USRP
<br />        #self._fusb_nblocks       = options.fusb_nblocks    # usb info for
<br />USRP
<br />        self._use_whitener_offset = options.use_whitener_offset # increment
<br />start of whitener XOR data
<br />        
<br />        self._modulator_class = modulator_class         # the
<br />modulator_class we are using
<br />    
<br />        if self._tx_freq is None:
<br />            sys.stderr.write("-f FREQ or --freq FREQ or --tx-freq FREQ must
<br />be specified\n")
<br />            raise SystemExit
<br />
<br />        # Set up USRP sink; also adjusts interp, samples_per_symbol, and
<br />bitrate
<br />        self._setup_usrp_sink()  
<br />
<br />        # copy the final answers back into options for use by modulator
<br />        options.samples_per_symbol = self._samples_per_symbol
<br />        options.bitrate = self._bitrate
<br />        options.interp = self._interp
<br />
<br />        # Get mod_kwargs
<br />        mod_kwargs =
<br />self._modulator_class.extract_kwargs_from_options(options)
<br />
<br />        # Set center frequency of USRP
<br />        ok = self.set_freq(self._tx_freq)
<br />        if not ok:
<br />            print "Failed to set Tx frequency to %s" %
<br />(eng_notation.num_to_str(self._tx_freq),)
<br />            raise ValueError
<br />    
<br />        # transmitter
<br />        self.packet_transmitter = \
<br />            blks2.mod_pkts(self._modulator_class(**mod_kwargs),
<br />                           access_code=None,
<br />                           msgq_limit=4,
<br />                           pad_for_usrp=True,
<br />                           use_whitener_offset=options.use_whitener_offset)
<br />
<br />
<br />        # Set the USRP for maximum transmit gain
<br />        # (Note that on the RFX cards this is a nop.)
<br />        self.set_gain(self.u.gain_range()[1])
<br />
<br />        self.amp = gr.multiply_const_cc(1)
<br />        self.set_tx_amplitude(self._tx_amplitude)
<br />
<br />        # enable Auto Transmit/Receive switching
<br />        #fiske_removed self.set_auto_tr(True)
<br />
<br />        # Display some information about the setup
<br />        if self._verbose:
<br />            self._print_verbage()
<br />
<br />        # Create and setup transmit path flow graph
<br />        self.connect(self.packet_transmitter, self.amp, self.u)
<br />
<br />    def _setup_usrp_sink(self):
<br />        """
<br />        Creates a USRP sink, determines the settings for best bitrate,
<br />        and attaches to the transmitter's subdevice.
<br />        """
<br />        #self.u = usrp2.source_32fc(options.interface, options.mac_addr)
<br />        #self.u = usrp2.sink_32fc (options._interface, options._mac_addr)
<br />        self.u = usrp2.sink_32fc("eth0","00:50:C2:85:31:5A")  #fiske hard coded 
<br />        dac_rate = self.u.dac_rate();
<br />
<br />        # derive values of bitrate, samples_per_symbol, and interp from
<br />desired info
<br />        (self._bitrate, self._samples_per_symbol, self._interp) = \
<br />            pick_tx_bitrate(self._bitrate,
<br />self._modulator_class.bits_per_symbol(),
<br />                            self._samples_per_symbol, self._interp,
<br />dac_rate)
<br />        
<br />        #fiske_removed self.u.set_interp_rate(self._interp)
<br />
<br />        # determine the daughterboard subdevice we're using
<br />        #if self._tx_subdev_spec is None:
<br />        #    self._tx_subdev_spec = usrp.pick_tx_subdevice(self.u)
<br />        #self.u.set_mux(usrp.determine_tx_mux_value(self.u,
<br />self._tx_subdev_spec))
<br />        #self.subdev = usrp.selected_subdev(self.u, self._tx_subdev_spec)
<br />
<br />
<br />    def set_freq(self, target_freq):
<br />        """
<br />        Set the center frequency we're interested in.
<br />
<br />        @param target_freq: frequency in Hz
<br />        @rypte: bool
<br />
<br />        Tuning is a two step process.  First we ask the front-end to
<br />        tune as close to the desired frequency as it can.  Then we use
<br />        the result of that operation and our target_frequency to
<br />        determine the value for the digital up converter.
<br />        """
<br />        r = self.u.set_center_freq(target_freq)
<br />        if r:
<br />            return True
<br />
<br />        return False
<br />        
<br />    def set_gain(self, gain):
<br />        """
<br />        Sets the analog gain in the USRP
<br />        """
<br />        self.gain = gain
<br />        self.u.set_gain(gain)
<br />
<br />    def set_tx_amplitude(self, ampl):
<br />        """
<br />        Sets the transmit amplitude sent to the USRP
<br />        @param: ampl 0 &lt;= ampl &lt; 32768.  Try 8000
<br />        """
<br />        self._tx_amplitude = max(0.0, min(ampl, 32767.0))
<br />        self.amp.set_k(self._tx_amplitude)
<br />        
<br />    def set_auto_tr(self, enable):
<br />        """
<br />        Turns on auto transmit/receive of USRP daughterboard (if exits; else
<br />ignored)
<br />        """
<br />        return self.u.set_auto_tr(enable)
<br />        
<br />    def send_pkt(self, payload='', eof=False):
<br />        """
<br />        Calls the transmitter method to send a packet
<br />        """
<br />        return self.packet_transmitter.send_pkt(payload, eof)
<br />        
<br />    def bitrate(self):
<br />        return self._bitrate
<br />
<br />    def samples_per_symbol(self):
<br />        return self._samples_per_symbol
<br />
<br />    def interp(self):
<br />        return self._interp
<br />
<br />    def add_options(normal, expert):
<br />        """
<br />        Adds transmitter-specific options to the Options Parser
<br />        """
<br />        add_freq_option(normal)
<br />        if not normal.has_option('--bitrate'):
<br />            normal.add_option("-r", "--bitrate", type="eng_float",
<br />default=None,
<br />                              help="specify bitrate.  samples-per-symbol and
<br />interp/decim will be derived.")
<br />        normal.add_option("-e", "--interface", type="string",
<br />default="eth0",
<br />                          help="select Ethernet interface, default is eth0")
<br />        normal.add_option("-m", "--mac-addr", type="string", default="",
<br />                          help="select USRP by MAC address, default is
<br />auto-select")
<br />        #normal.add_option("-T", "--tx-subdev-spec", type="subdev",
<br />default=None,
<br />        #                  help="select USRP Tx side A or B")
<br />        normal.add_option("", "--tx-amplitude", type="eng_float",
<br />default=12000, metavar="AMPL",
<br />                          help="set transmitter digital amplitude: 0 &lt;= AMPL
<br />&lt; 32768 [default=%default]")
<br />        normal.add_option("-v", "--verbose", action="store_true",
<br />default=False)
<br />
<br />        expert.add_option("-S", "--samples-per-symbol", type="int",
<br />default=None,
<br />                          help="set samples/symbol [default=%default]")
<br />        expert.add_option("", "--tx-freq", type="eng_float", default=None,
<br />                          help="set transmit frequency to FREQ
<br />[default=%default]", metavar="FREQ")
<br />        expert.add_option("-i", "--interp", type="intx", default=None,
<br />                          help="set fpga interpolation rate to INTERP
<br />[default=%default]")
<br />        expert.add_option("", "--log", action="store_true", default=False,
<br />                          help="Log all parts of flow graph to file
<br />(CAUTION: lots of data)")
<br />        expert.add_option("","--use-whitener-offset", action="store_true",
<br />default=False,
<br />                          help="make sequential packets use different
<br />whitening")
<br />
<br />    # Make a static method to call before instantiation
<br />    add_options = staticmethod(add_options)
<br />
<br />    def _print_verbage(self):
<br />        """
<br />        Prints information about the transmit path
<br />        """
<br />        print "Using TX d'board %s"    % (self.u.daughterboard_id(),)
<br />        print "Tx amplitude     %s"    % (self._tx_amplitude)
<br />        print "modulation:      %s"    % (self._modulator_class.__name__)
<br />        print "bitrate:         %sb/s" %
<br />(eng_notation.num_to_str(self._bitrate))
<br />        print "samples/symbol:  %3d"   % (self._samples_per_symbol)
<br />        print "interp:          %3d"   % (self._interp)
<br />        print "Tx Frequency:    %s"    %
<br />(eng_notation.num_to_str(self._tx_freq))
<br />        
<br />
<br />def add_freq_option(parser):
<br />    """
<br />    Hackery that has the -f / --freq option set both tx_freq and rx_freq
<br />    """
<br />    def freq_callback(option, opt_str, value, parser):
<br />        parser.values.rx_freq = value
<br />        parser.values.tx_freq = value
<br />
<br />    if not parser.has_option('--freq'):
<br />        parser.add_option('-f', '--freq', type="eng_float",
<br />                          action="callback", callback=freq_callback,
<br />                          help="set Tx and/or Rx frequency to FREQ
<br />[default=%default]",
<br />                          metavar="FREQ")
<br />
<br />benchmark_rx.py
<br />
<br />#!/usr/bin/env python
<br />#
<br /># Copyright 2005,2006,2007 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />from gnuradio import gr, gru, modulation_utils
<br />from gnuradio import usrp2
<br />from gnuradio import eng_notation
<br />from gnuradio.eng_option import eng_option
<br />from optparse import OptionParser
<br />
<br />import random
<br />import struct
<br />import sys
<br />
<br /># from current dir
<br />from receive_path_usrp2 import receive_path
<br />import fusb_options
<br />
<br />#import os
<br />#print os.getpid()
<br />#raw_input('Attach and press enter: ')
<br />
<br />class my_top_block(gr.top_block):
<br />    def __init__(self, demodulator, rx_callback, options):
<br />        gr.top_block.__init__(self)
<br />        self.rxpath = receive_path(demodulator, rx_callback, options) 
<br />        self.connect(self.rxpath)
<br />
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />#                                   main
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />
<br />global n_rcvd, n_right
<br />
<br />def main():
<br />    global n_rcvd, n_right
<br />
<br />    n_rcvd = 0
<br />    n_right = 0
<br />    
<br />    def rx_callback(ok, payload):
<br />        global n_rcvd, n_right
<br />        (pktno,) = struct.unpack('!H', payload[0:2])
<br />        n_rcvd += 1
<br />        if ok:
<br />            n_right += 1
<br />
<br />        print "ok = %5s  pktno = %4d  n_rcvd = %4d  n_right = %4d" % (
<br />            ok, pktno, n_rcvd, n_right)
<br />
<br />
<br />    demods = modulation_utils.type_1_demods()
<br />
<br />    # Create Options Parser:
<br />    parser = OptionParser (option_class=eng_option,
<br />conflict_handler="resolve")
<br />    expert_grp = parser.add_option_group("Expert")
<br />
<br />    parser.add_option("-m", "--modulation", type="choice",
<br />choices=demods.keys(), 
<br />                      default='gmsk',
<br />                      help="Select modulation from: %s [default=%%default]"
<br />                            % (', '.join(demods.keys()),))
<br />
<br />    receive_path.add_options(parser, expert_grp)
<br />
<br />    for mod in demods.values():
<br />        mod.add_options(expert_grp)
<br />
<br />    fusb_options.add_options(expert_grp)
<br />    (options, args) = parser.parse_args ()
<br />
<br />    if len(args) != 0:
<br />        parser.print_help(sys.stderr)
<br />        sys.exit(1)
<br />
<br />    if options.rx_freq is None:
<br />        sys.stderr.write("You must specify -f FREQ or --freq FREQ\n")
<br />        parser.print_help(sys.stderr)
<br />        sys.exit(1)
<br />
<br />
<br />    # build the graph
<br />    tb = my_top_block(demods[options.modulation], rx_callback, options)
<br />
<br />    r = gr.enable_realtime_scheduling()
<br />    if r != gr.RT_OK:
<br />        print "Warning: Failed to enable realtime scheduling."
<br />
<br />    tb.start()        # start flow graph
<br />    tb.wait()         # wait for it to finish
<br />
<br />if __name__ == '__main__':
<br />    try:
<br />        main()
<br />    except KeyboardInterrupt:
<br />        pass
<br />
<br />receive_path_usrp2.py
<br />
<br />#!/usr/bin/env python
<br />#
<br /># Copyright 2005,2006,2007 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />from gnuradio import gr, gru, blks2
<br />from gnuradio import usrp2
<br />from gnuradio import eng_notation
<br />import copy
<br />import sys
<br />
<br /># from current dir
<br />from pick_bitrate import pick_rx_bitrate
<br />
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />#                              receive path
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />
<br />class receive_path(gr.hier_block2):
<br />    def __init__(self, demod_class, rx_callback, options):
<br />
<br />        gr.hier_block2.__init__(self, "receive_path",
<br />                                gr.io_signature(0, 0, 0), # Input signature
<br />                                gr.io_signature(0, 0, 0)) # Output signature
<br />
<br />        options = copy.copy(options)    # make a copy so we can
<br />destructively modify
<br />
<br />        self._interface          = options.interface           # the USRP
<br />board attached
<br />        self._mac_addr           = options.mac_addr
<br />        self._verbose            = options.verbose
<br />        self._rx_freq            = options.rx_freq         # receiver's
<br />center frequency
<br />        self._rx_gain            = options.rx_gain         # receiver's gain
<br />        #self._rx_subdev_spec     = options.rx_subdev_spec  # daughterboard
<br />to use
<br />        self._bitrate            = options.bitrate         # desired bit
<br />rate 
<br />        self._decim              = options.decim           # Decimating rate
<br />for the USRP (prelim) 
<br />        self._samples_per_symbol = options.samples_per_symbol  # desired
<br />samples/symbol
<br />        self._fusb_block_size    = options.fusb_block_size # usb info for USRP
<br />        self._fusb_nblocks       = options.fusb_nblocks    # usb info for
<br />USRP
<br />
<br />        self._rx_callback   = rx_callback      # this callback is fired when
<br />there's a packet available
<br />        self._demod_class   = demod_class      # the demodulator_class we're
<br />using
<br />
<br />        if self._rx_freq is None:
<br />            sys.stderr.write("-f FREQ or --freq FREQ or --rx-freq FREQ must
<br />be specified\n")
<br />            raise SystemExit
<br />
<br />        # Set up USRP source; also adjusts decim, samples_per_symbol, and
<br />bitrate
<br />        self._setup_usrp_source()
<br />
<br />        g = self.u.gain_range()
<br />        if options.show_rx_gain_range:
<br />            print "Rx Gain Range: minimum = %g, maximum = %g, step size =
<br />%g" \
<br />                  % (g[0], g[1], g[2])
<br />
<br />        self.set_gain(options.rx_gain)
<br />
<br />        self.set_auto_tr(True)                 # enable Auto
<br />Transmit/Receive switching
<br />
<br />        # Set RF frequency
<br />        ok = self.set_freq(self._rx_freq)
<br />        if not ok:
<br />            print "Failed to set Rx frequency to %s" %
<br />(eng_notation.num_to_str(self._rx_freq))
<br />            raise ValueError, eng_notation.num_to_str(self._rx_freq)
<br />
<br />        # copy the final answers back into options for use by demodulator
<br />        options.samples_per_symbol = self._samples_per_symbol
<br />        options.bitrate = self._bitrate
<br />        options.decim = self._decim
<br />
<br />        # Get demod_kwargs
<br />        demod_kwargs =
<br />self._demod_class.extract_kwargs_from_options(options)
<br />        # Fix USRP2 -&gt; USRP1 scaling
<br />        self.scale = gr.multiply_const_cc(32768)
<br />        # Design filter to get actual channel we want
<br />        sw_decim = 1
<br />        chan_coeffs = gr.firdes.low_pass (1.0,                  # gain
<br />                                          sw_decim *
<br />self._samples_per_symbol, # sampling rate
<br />                                          1.0,                  # midpoint
<br />of trans. band
<br />                                          0.5,                  # width of
<br />trans. band
<br />                                          gr.firdes.WIN_HANN)   # filter
<br />type 
<br />
<br />        # Decimating channel filter
<br />        # complex in and out, float taps
<br />        self.chan_filt = gr.fft_filter_ccc(sw_decim, chan_coeffs)
<br />        #self.chan_filt = gr.fir_filter_ccf(sw_decim, chan_coeffs)
<br />
<br />        # receiver
<br />        self.packet_receiver = \
<br />            blks2.demod_pkts(self._demod_class(**demod_kwargs),
<br />                             access_code=None,
<br />                             callback=self._rx_callback,
<br />                             threshold=-1)
<br />    
<br />        # Carrier Sensing Blocks
<br />        alpha = 0.001
<br />        thresh = 30   # in dB, will have to adjust
<br />
<br />        if options.log_rx_power == True:
<br />            self.probe = gr.probe_avg_mag_sqrd_cf(thresh,alpha)
<br />            self.power_sink = gr.file_sink(gr.sizeof_float, "rxpower.dat")
<br />            self.connect(self.chan_filt, self.probe, self.power_sink)
<br />        else:
<br />            self.probe = gr.probe_avg_mag_sqrd_c(thresh,alpha)
<br />            self.connect(self.chan_filt, self.probe)
<br />
<br />        # Display some information about the setup
<br />        if self._verbose:
<br />            self._print_verbage()
<br />            
<br />        self.connect(self.u, self.scale, self.chan_filt,
<br />self.packet_receiver)
<br />
<br />    def _setup_usrp_source(self):
<br />        self.u = usrp2.source_32fc (self._interface, self._mac_addr)
<br />        adc_rate = self.u.adc_rate()
<br />
<br />        # derive values of bitrate, samples_per_symbol, and decim from
<br />desired info
<br />        (self._bitrate, self._samples_per_symbol, self._decim) = \ 
<br />            pick_rx_bitrate(self._bitrate,
<br />self._demod_class.bits_per_symbol(), \
<br />                            self._samples_per_symbol, self._decim, adc_rate) 
<br />
<br />        self.u.set_decim(self._decim)
<br />        # determine the daughterboard subdevice we're using
<br />        #if self._rx_subdev_spec is None:
<br />        #    self._rx_subdev_spec = usrp.pick_rx_subdevice(self.u)
<br />        #self.subdev = usrp.selected_subdev(self.u, self._rx_subdev_spec)
<br />
<br />        #self.u.set_mux(usrp.determine_rx_mux_value(self.u,
<br />self._rx_subdev_spec))
<br />
<br />    def set_freq(self, target_freq):
<br />        """
<br />        Set the center frequency we're interested in.
<br />
<br />        @param target_freq: frequency in Hz
<br />        @rypte: bool
<br />
<br />        Tuning is a two step process.  First we ask the front-end to
<br />        tune as close to the desired frequency as it can.  Then we use
<br />        the result of that operation and our target_frequency to
<br />        determine the value for the digital up converter.
<br />        """
<br />        r = self.u.set_center_freq(target_freq)
<br />        if r:
<br />            return True
<br />
<br />        return False
<br />
<br />    def set_gain(self, gain):
<br />        """
<br />        Sets the analog gain in the USRP
<br />        """
<br />        if gain is None:
<br />            r = self.u.gain_range()
<br />            gain = (r[0] + r[1])/2               # set gain to midpoint
<br />        self.gain = gain
<br />        return self.u.set_gain(gain)
<br />
<br />    def set_auto_tr(self, enable):
<br />        #return self.u.set_auto_tr(enable)
<br />        return
<br />        
<br />    def bitrate(self):
<br />        return self._bitrate
<br />
<br />    def samples_per_symbol(self):
<br />        return self._samples_per_symbol
<br />
<br />    def decim(self):
<br />        return self._decim
<br />
<br />    def carrier_sensed(self):
<br />        """
<br />        Return True if we think carrier is present.
<br />        """
<br />        #return self.probe.level() &gt; X
<br />        return self.probe.unmuted()
<br />
<br />    def carrier_threshold(self):
<br />        """
<br />        Return current setting in dB.
<br />        """
<br />        return self.probe.threshold()
<br />
<br />    def set_carrier_threshold(self, threshold_in_db):
<br />        """
<br />        Set carrier threshold.
<br />
<br />        @param threshold_in_db: set detection threshold
<br />        @type threshold_in_db:  float (dB)
<br />        """
<br />        self.probe.set_threshold(threshold_in_db)
<br />    
<br />        
<br />    def add_options(normal, expert):
<br />        """
<br />        Adds receiver-specific options to the Options Parser
<br />        """
<br />        add_freq_option(normal)
<br />        if not normal.has_option("--bitrate"):
<br />            normal.add_option("-r", "--bitrate", type="eng_float",
<br />default=None,
<br />                              help="specify bitrate.  samples-per-symbol and
<br />interp/decim will be derived.")
<br />        normal.add_option("-e", "--interface", type="string",
<br />default="eth0",
<br />                          help="select Ethernet interface, default is eth0")
<br />        normal.add_option("-m", "--mac-addr", type="string", default="",
<br />                          help="select USRP by MAC address, default is
<br />auto-select")
<br />        #normal.add_option("-R", "--rx-subdev-spec", type="subdev",
<br />default=None,
<br />        #                  help="select USRP Rx side A or B")
<br />        normal.add_option("", "--rx-gain", type="eng_float", default=None,
<br />metavar="GAIN",
<br />                          help="set receiver gain in dB [default=midpoint]. 
<br />See also --show-rx-gain-range")
<br />        normal.add_option("", "--show-rx-gain-range", action="store_true",
<br />default=False, 
<br />                          help="print min and max Rx gain available on
<br />selected daughterboard")
<br />        normal.add_option("-v", "--verbose", action="store_true",
<br />default=False)
<br />        expert.add_option("-S", "--samples-per-symbol", type="int",
<br />default=None,
<br />                          help="set samples/symbol [default=%default]")
<br />        expert.add_option("", "--rx-freq", type="eng_float", default=None,
<br />                          help="set Rx frequency to FREQ
<br />[default=%default]", metavar="FREQ")
<br />        expert.add_option("-d", "--decim", type="intx", default=None,
<br />                          help="set fpga decimation rate to DECIM
<br />[default=%default]")
<br />        expert.add_option("", "--log", action="store_true", default=False,
<br />                          help="Log all parts of flow graph to files
<br />(CAUTION: lots of data)")
<br />        expert.add_option("", "--log-rx-power", action="store_true",
<br />default=False,
<br />                          help="Log receive signal power to file (CAUTION:
<br />lots of data)")
<br />
<br />    # Make a static method to call before instantiation
<br />    add_options = staticmethod(add_options)
<br />
<br />
<br />    def _print_verbage(self):
<br />        """
<br />        Prints information about the receive path
<br />        """
<br />        print "\nReceive Path:"
<br />        print "Using RX d'board %s"    % (self.u.daughterboard_id(),)
<br />        print "Rx gain:         %g"    % (self.gain,)
<br />        print "modulation:      %s"    % (self._demod_class.__name__)
<br />        print "bitrate:         %sb/s" %
<br />(eng_notation.num_to_str(self._bitrate))
<br />        print "samples/symbol:  %3d"   % (self._samples_per_symbol)
<br />        print "decim:           %3d"   % (self._decim)
<br />        print "Rx Frequency:    %s"    %
<br />(eng_notation.num_to_str(self._rx_freq))
<br />        # print "Rx Frequency:    %f"    % (self._rx_freq)
<br />
<br />    def __del__(self):
<br />        # Avoid weak reference error
<br />        #del self.subdev
<br />        return
<br />            
<br />def add_freq_option(parser):
<br />    """
<br />    Hackery that has the -f / --freq option set both tx_freq and rx_freq
<br />    """
<br />    def freq_callback(option, opt_str, value, parser):
<br />        parser.values.rx_freq = value
<br />        parser.values.tx_freq = value
<br />
<br />    if not parser.has_option('--freq'):
<br />        parser.add_option('-f', '--freq', type="eng_float",
<br />                          action="callback", callback=freq_callback,
<br />                          help="set Tx and/or Rx frequency to FREQ
<br />[default=%default]",
<br />                          metavar="FREQ")
<br />
<br />pick_bitrate.py
<br />
<br />#
<br /># Copyright 2005,2006 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />_default_bitrate = 500e3
<br />
<br />_valid_samples_per_symbol = (2,3,4,5,6,7)
<br />
<br />def _gen_tx_info(converter_rate):
<br />    results = []
<br />    for samples_per_symbol in _valid_samples_per_symbol:
<br />        for interp in range(16, 512 + 1, 4):
<br />            bitrate = converter_rate / interp / samples_per_symbol
<br />            results.append((bitrate, samples_per_symbol, interp))
<br />    results.sort()
<br />    return results
<br />
<br />def _gen_rx_info(converter_rate):
<br />    results = []
<br />    for samples_per_symbol in _valid_samples_per_symbol:
<br />        for decim in range(8, 256 + 1, 2):
<br />            bitrate = converter_rate / decim / samples_per_symbol
<br />            results.append((bitrate, samples_per_symbol, decim))
<br />    results.sort()
<br />    return results
<br />    
<br />def _filter_info(info, samples_per_symbol, xrate):
<br />    if samples_per_symbol is not None:
<br />        info = [x for x in info if x[1] == samples_per_symbol]
<br />    if xrate is not None:
<br />        info = [x for x in info if x[2] == xrate]
<br />    return info
<br />
<br />def _pick_best(target_bitrate, bits_per_symbol, info):
<br />    """
<br />    @returns tuple (bitrate, samples_per_symbol, interp_rate_or_decim_rate)
<br />    """
<br />    if len(info) == 0:
<br />        raise RuntimeError, "info is zero length!"
<br />
<br />    if target_bitrate is None:     # return the fastest one
<br />        return info[-1]
<br />    
<br />    # convert bit rate to symbol rate
<br />    target_symbolrate = target_bitrate / bits_per_symbol
<br />    
<br />    # Find the closest matching symbol rate.
<br />    # In the event of a tie, the one with the lowest samples_per_symbol
<br />wins.
<br />    # (We already sorted them, so the first one is the one we take)
<br />
<br />    best = info[0]
<br />    best_delta = abs(target_symbolrate - best[0])
<br />    for x in info[1:]:
<br />        delta = abs(target_symbolrate - x[0])
<br />        if delta &lt; best_delta:
<br />            best_delta = delta
<br />            best = x
<br />
<br />    # convert symbol rate back to bit rate
<br />    return ((best[0] * bits_per_symbol),) + best[1:]
<br />
<br />def _pick_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                  xrate, converter_rate, gen_info):
<br />    """
<br />    @returns tuple (bitrate, samples_per_symbol, interp_rate_or_decim_rate)
<br />    """
<br />    if not isinstance(bits_per_symbol, int) or bits_per_symbol &lt; 1:
<br />        raise ValueError, "bits_per_symbol must be an int &gt;= 1"
<br />    
<br />    if samples_per_symbol is not None and xrate is not None:  # completely
<br />determined
<br />        return (float(converter_rate) / xrate / samples_per_symbol,
<br />                samples_per_symbol, xrate)
<br />
<br />    if bitrate is None and samples_per_symbol is None and xrate is None:
<br />        bitrate = _default_bitrate
<br />
<br />    # now we have a target bitrate and possibly an xrate or
<br />    # samples_per_symbol constraint, but not both of them.
<br />
<br />    return _pick_best(bitrate, bits_per_symbol,
<br />                      _filter_info(gen_info(converter_rate),
<br />samples_per_symbol, xrate))
<br />    
<br />#
<br />---------------------------------------------------------------------------------------
<br />
<br />def pick_tx_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                    interp_rate, converter_rate=128e6): 
<br />    """
<br />    Given the 4 input parameters, return at configuration that matches
<br />
<br />    @param bitrate: desired bitrate or None
<br />    @type bitrate: number or None
<br />    @param bits_per_symbol: E.g., BPSK -&gt; 1, QPSK -&gt; 2, 8-PSK -&gt; 3
<br />    @type bits_per_symbol: integer &gt;= 1
<br />    @param samples_per_symbol: samples/baud (aka samples/symbol)
<br />    @type samples_per_symbol: number or None
<br />    @param interp_rate: USRP interpolation factor
<br />    @type interp_rate: integer or None
<br />    @param converter_rate: converter sample rate in Hz
<br />    @type converter_rate: number
<br />
<br />    @returns tuple (bitrate, samples_per_symbol, interp_rate)
<br />    """
<br />    return _pick_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                         interp_rate, converter_rate, _gen_tx_info)
<br />
<br />
<br />def pick_rx_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                    decim_rate, converter_rate=64e6): 
<br />    """
<br />    Given the 4 input parameters, return at configuration that matches
<br />
<br />    @param bitrate: desired bitrate or None
<br />    @type bitrate: number or None
<br />    @param bits_per_symbol: E.g., BPSK -&gt; 1, QPSK -&gt; 2, 8-PSK -&gt; 3
<br />    @type bits_per_symbol: integer &gt;= 1
<br />    @param samples_per_symbol: samples/baud (aka samples/symbol)
<br />    @type samples_per_symbol: number or None
<br />    @param decim_rate: USRP decimation factor
<br />    @type decim_rate: integer or None
<br />    @param converter_rate: converter sample rate in Hz
<br />    @type converter_rate: number
<br />
<br />    @returns tuple (bitrate, samples_per_symbol, decim_rate)
<br />    """
<br />    return _pick_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                         decim_rate, converter_rate, _gen_rx_info)
<br />
<br />Thanks in advance for your cooperation.</pre><br /><span style="font-size: large;"><b>(2)</b></span><br /><br /><pre>Hi,
<br />
<br />This is what I get when I run benchmark _tx.py and benchmark_rx.py
<br />respectively on USRP2 with transmit_path_usrp2.py and receive_path_usrp2.py
<br />respectively:
<br />
<br />benchmark_tx.py:-
<br />
<br />m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$ sudo
<br />./benchmark_tx.py -f 2400M -v
<br />usrp2::ctor reset_db failed
<br />usrp2::ctor set_rx_gain failed
<br />usrp2::ctor set_tx_interp failed
<br />usrp2::ctor set_rx_scale_iq failed
<br />&gt;&gt;&gt; gr_fir_fff: using SSE
<br />bits per symbol = 1
<br />Gaussian filter bt = 0.35
<br />Using TX d'board 43
<br />Tx amplitude     12000
<br />modulation:      gmsk_mod
<br />bitrate:         500kb/s
<br />samples/symbol:    2
<br />interp:          100
<br />Tx Frequency:    2.4G
<br />...........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$
<br /> 
<br />
<br />benchmark_rx.py:-
<br />
<br />m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$ sudo
<br />./benchmark_rx.py -f 2400M -v
<br />usrp2::ctor reset_db failed
<br />&gt;&gt;&gt; gr_fir_fff: using SSE
<br />bits per symbol = 1
<br />M&amp;M clock recovery omega = 2.000000
<br />M&amp;M clock recovery gain mu = 0.175000
<br />M&amp;M clock recovery mu = 0.500000
<br />M&amp;M clock recovery omega rel. limit = 0.005000
<br />frequency error = 0.000000
<br />
<br />Receive Path:
<br />Using RX d'board 39
<br />Rx gain:         35
<br />modulation:      gmsk_demod
<br />bitrate:         500kb/s
<br />samples/symbol:    2
<br />decim:           100
<br />Rx Frequency:    2.4G
<br />
<br />
<br />Now the same thing for usrp1 but using transmit_path.py and receive_path.py
<br />which is already provided in gnuradio:
<br />
<br />benchmark_tx.py:-
<br />
<br />m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$ sudo
<br />./benchmark_tx.py -f 2400M -v
<br />&gt;&gt;&gt; gr_fir_fff: using SSE
<br />bits per symbol = 1
<br />Gaussian filter bt = 0.35
<br />Using TX d'board A: Flex 2400 Tx MIMO B
<br />Tx amplitude     12000
<br />modulation:      gmsk_mod
<br />bitrate:         500kb/s
<br />samples/symbol:    2
<br />interp:          128
<br />Tx Frequency:    2.4G
<br />...........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$
<br /> 
<br />
<br />benchmark_rx.py:-
<br />
<br />m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$ sudo
<br />./benchmark_rx.py -f 2400M -v
<br />&gt;&gt;&gt; gr_fir_fff: using SSE
<br />bits per symbol = 1
<br />M&amp;M clock recovery omega = 2.000000
<br />M&amp;M clock recovery gain mu = 0.175000
<br />M&amp;M clock recovery mu = 0.500000
<br />M&amp;M clock recovery omega rel. limit = 0.005000
<br />frequency error = 0.000000
<br />
<br />Receive Path:
<br />Using RX d'board A: Flex 2400 Rx MIMO B
<br />Rx gain:         45
<br />modulation:      gmsk_demod
<br />bitrate:         500kb/s
<br />samples/symbol:    2
<br />decim:            64
<br />Rx Frequency:    2.4G
<br />
<br />I am using the same pick_bitrate.py file that is already provided in
<br />gnuradio. As it can be seen that both usrp systems have the default bit rate
<br />irrespective of whether it acts as receiver or transmitter. My concern is
<br />with the interpolation and decimation. Do I need to make changes to the
<br />pick_bitrate.py file for USRP2? If yes, then what kind of changes. I also
<br />observed that even though USRP2 shows a bit rate of 500kbps, however I
<br />believe that its transmitting too fast which does not allow USRP1 to receive
<br />correctly.I would greatly appreciate any help in this matter.
<br />
<br />Thanks in advance.
<br />
<br /><b><span style="font-size: large;">(3)</span></b></pre><br /><pre>At a minimum, you will need to call pick_tx_bitrate and
<br />pick_rx_bitrate providing proper rates for the ADC and DAC.  They
<br />default to the values appropriate for the USRP1.  However, it looks
<br />like you'll need a USRP2 version since they encode the acceptable
<br />ranges for interpolation and decimation which are different between
<br />the USRP1 and USRP2.
<br />
<br />Eric</pre><br /><b><span style="font-size: large;">(4)</span></b><br /><br /><pre>Hi,
<br />
<br />I already tried to set the value of the converter_rate in pick_tx_bitrate
<br />and Pick_rx_bitrate according to the ADC and DAC specifications of u...@. I
<br />set it to 200e6 in pick_tx_bitrate and in pick_rx_bitrate. But even that did
<br />not worked. I am confused with how to modify the pick_bitrate.py file for
<br />usrp2. I am not able to determine the different parameters that I need to
<br />provide for usrp2. If anyone has already worked on it then please help me to
<br />modify the pick_bitrate file for usrp2. Also if any other changes are
<br />required in other python files.
<br />
<br />Thanks in advance.
<br />
<br />Smith</pre><br /><b><span style="font-size: large;">(5)</span></b><br /><br /><tt>The DAC rate is 100e6.  The &#8220;bitrate&#8221; is the desired data rate of the  </tt><tt>over the air modulation.  It should be MUCH less, like 100k to 1M or so. </tt><br /><tt>There is absolutely nothing in any of the systems for which 200e6 is a  </tt><tt>correct choice. </tt><br /><pre style="margin: 0em;">Matt</pre></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/17/why-dont-you-read-readme-file-first/">Why Dont You Read the Readme File First?!</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-17T00:00:00-05:00" pubdate data-updated="true">Oct 17<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
it&#8217;s fucking awful to find everything in readme file, while I spent nearly 10 hours wander around in the internet&#8230;&#8230;<br /><br />==========<br /><br />/gnuradio3.2.2/gnuradio-examples/python/digital/README<br /><br />Quick overview of what&#8217;s here:<br /><br />* benchmark_tx.py: generates packets of the size you<br />specify and sends them across the air using the USRP.&nbsp; Known to work<br />well using the USRP with the RFX transceiver daughterboards.<br />You can specify the bitrate to use with the -r <bitrate> command line<br />parameter.&nbsp; The default is 500k.&nbsp; Some machines will do 1M or more.<br />You can select the modulation to use with the -m <modulation> command<br />line argument.&nbsp; The legal values for <modulation> are gmsk, dbpsk and dqpsk.<br /><br />* benchmark_rx.py: the receiver half of benchmark_tx.py.<br />Command line arguments are pretty much the same as rx.&nbsp; Works well<br />with a USRP and RFX transceiver daughterboards.&nbsp; Will also work<br />with TVRX daugherboard, but you&#8217;ll need to fiddle with the gain.&nbsp; See<br />below.&nbsp; Prints a summary of each packet received and keeps a running<br />total of packets received, and how many of them were error free.<br />There are two levels of error reporting going on.&nbsp; If the access code<br />(PN code) and header of a packet were properly detected, then you&#8217;ll<br />get an output line.&nbsp; If the CRC32 of the payload was correct you get<br />&#8220;ok = True&#8221;, else &#8220;ok = False&#8221;.&nbsp; The &#8220;pktno&#8221; is extracted from the<br />received packet.&nbsp; If there are skipped numbers, you&#8217;re missing some<br />packets.&nbsp; Be sure you&#8217;ve got a suitable antenna connected to the TX/RX<br />port on each board.&nbsp; For the RFX-400, &#8220;70 cm&#8221; / 420 MHz antennas for ham<br />handi-talkies work great.&nbsp; These are available at ham radio supplies,<br />etc.&nbsp; The boards need to be at least 3m apart.&nbsp; You can also try<br />experimenting with the rx gain (-g <gain> command line option).<br /><br />Generally speaking, I start the rx first on one machine, and then fire<br />up the tx on the other machine.&nbsp; The tx also supports a discontinous<br />transmission mode where it sends bursts of 5 packets and then waits 1<br />second.&nbsp; This is useful for ensuring that all the receiver control<br />loops lock up fast enough.<br /><br />* tunnel.py: This program provides a framework for building your own<br />MACs.&nbsp; It creates a &#8220;TAP&#8221; interface in the kernel, typically gr0,<br />and sends and receives ethernet frames through it.&nbsp; See<br />/usr/src/linux/Documentation/networking/tuntap.txt and/or Google for<br />&#8220;universal tun tap&#8221;.&nbsp; The Linux 2.6 kernel includes the tun module, you<br />don&#8217;t have to build it.&nbsp; You may have to &#8220;modprobe tun&#8221; if it&#8217;s not<br />loaded by default.&nbsp; If /dev/net/tun doesn&#8217;t exist, try &#8220;modprobe tun&#8221;.<br /><br />To run this program you&#8217;ll need to be root or running with the<br />appropriate capability to open the tun interface.&nbsp; You&#8217;ll need to fire<br />up two copies on different machines.&nbsp; Once each is running you&#8217;ll need<br />to ifconfig the gr0 interface to set the IP address.<br /><br />This will allow two machines to talk, but anything beyond the two<br />machines depends on your networking setup.&nbsp; Left as an exercise&#8230;<br /><br />On machine A:<br /><br />&nbsp; $ su<br />&nbsp; # ./tunnel.py &#8211;freq 423.0M &#8211;bitrate 500k<br />&nbsp; # # in another window on A, also as root&#8230;<br />&nbsp; # ifconfig gr0 192.168.200.1<br /><br /><br />On machine B:<br /><br />&nbsp; $ su<br />&nbsp; # ./tunnel.py &#8211;freq 423.0M &#8211;bitrate 500k<br />&nbsp; # # in another window on B, also as root&#8230;<br />&nbsp; # ifconfig gr0 192.168.200.2<br /><br />Now, on machine A you shold be able to ping machine B:<br /><br />&nbsp; $ ping 192.168.200.2<br /><br />and you should see some output for each packet in the<br />tunnel.py window if you used the -v option.<br /><br />Likewise, on machine B:<br /><br />&nbsp; $ ping 192.168.200.1<br /><br />This now uses a carrier sense MAC, so you should be able to ssh<br />between the machines, web browse, etc.<br /><br />* run_length.py: This program takes a single argument &#8216;-f FILE&#8217; and<br />outputs the number of runs of similar bits within the file. It is<br />useful as a diagnostic tool when experimenting with line coding or<br />whitening algorithms.</gain></modulation></modulation></bitrate></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
patpat~<br />lan</div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/17/how-to-test-usrp-when-you-get-it/">How to Test USRP When You Get It</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-17T00:00:00-05:00" pubdate data-updated="true">Oct 17<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
<span style="font-family: Arial;"><b>prerequisites:</b><br />1. install Linux: need to select a OS <a href="http://gnuradio.org/trac/wiki/GettingStarted">here</a></span><br /><span style="font-family: Arial;">2. install GNU Radio:&nbsp;&nbsp;&nbsp; &#8211;<a href="http://gnuradio.org/trac/wiki">http://gnuradio.org/trac/wiki</a></span><br /><span style="font-family: Arial;">3. (optional) read the hardware documents:&nbsp;&nbsp;&nbsp; &#8211;<a href="http://gnuradio.org/trac/wiki/USRP">http://gnuradio.org/trac/wiki/USRP</a> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user guide/install guide:&nbsp;&nbsp;&nbsp; &#8211;<a href="http://www.comsec.com/wiki?UsrpInstall">http://www.comsec.com/wiki?UsrpInstall</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All the datasheets can be downloaded <a href="http://www.wu.ece.ufl.edu/projects/wirelessVideo/project/GNU_Radio_USRP/datasheet.zip"> here</a></span><br /><span style="font-family: Arial;">4. (optional) read driver source code <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the source codes related to USRP:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /usrp<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  firmware: for 8051 in USB controller, mostly writen as .c and .a51<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  FPGA: for FPGA, mostly writen as .v (it seems fpga only has SRAM inside, so it  need to download software for fpga every time)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  host: for PC, mostly writen as .cc<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /gr-usrp<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  driver for dauther board: mostly writen as .py and .cc<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  /gnuradio-example/python/usrp<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  example for single usrp board: all writen in .py<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  /gnuradio-example/python/multi-usrp<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  example for multi usrp boards: all writen in .py</span><br /><span style="font-family: Arial;"> <br /><b>begin to test:</b><br />1. How to power on and start test:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; step1. before plug in USB cable, open  two terminal.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; step2. to see a real time display of  all log messages: tail -f /var/log/messages (to check the usb driver is  correctly installed)<br />&nbsp;&nbsp;&nbsp; How to stop and power off:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; step1. stop the program.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; step2. disconnect USB connection and  power off</span><br /><span style="font-family: Arial;">2. test a script for usrp first without daughter board, which file I need to  test? <br />&#8211;<a href="http://www.comsec.com/wiki?UsrpInstall">http://www.comsec.com/wiki?UsrpInstall</a><br />gnuradio\gnuradio-examples\python\usrp\usrp_siggen.py &amp; usrp_fft.py<br /><br />3. how to test the transmitter and receiver for daughter board?<br />The antenna should be connect by Tx/Rx SMA but NOT Rx2! there is a switch for  Rx2 and the switch is off in default!<br />The Tx and Rx can NOT be connected directly by cable! need a attenuator about  40-50 dB!!<br />&nbsp;&nbsp;&nbsp; 1) /gnuradio-examples/python/usrp/usrp_siggen.py and usrp_fft.py to observe  signal<br />&nbsp;&nbsp;&nbsp; 2) /gnuradio-examples/python/digital/benchmark_tx.py and benchmark_rx.py to test  data transmission.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The boards need to be at least 3m  apart. &#8211;/home/james/gnuradio/gnuradio-examples/python/digital/README<br />&nbsp;&nbsp;&nbsp; 3) use tx_voice.py and rx_voice.py to test voice transmission. <br />&nbsp;&nbsp;&nbsp; 4) some also said to test /gnuradio-examples/python/usrp/usrp_nbfm_ptt.py to  test full duplex voice call, but I can&#8217;t make it works.<br /><br /><b>test voice:</b><br />1. gnuradio-examples\python\audio\dial_tone.py as tutorial<br />2. gnuradio-examples\python\audio\audio_copy.py<br />&nbsp;&nbsp;&nbsp; gnuradio-examples\python\audio\audio_to_file.py<br />&nbsp;&nbsp;&nbsp; gnuradio-examples\python\audio\audio_play.py<br />3. gnuradio-examples\python\digital_voice\encdec.py to test by one USRP<br />4.  gnuradio-examples\python\digital\tx_voice.py<br />&nbsp;&nbsp;&nbsp; gnuradio-examples\python\digital\rx_voice.py to test by two  USRP<br /><br /><b>test data:</b><br />1.  gnuradio-examples\python\digital\benchmark_tx.py<br />&nbsp;&nbsp;&nbsp; gnuradio-examples\python\digital\benchmark_rx.py to test by  two USRP<br /><br /><b>suggested by others:</b><br />1. <a href="http://www.nabble.com/High-packet-error-and-reception-problems-with-RFX-2400-t3522095.html"> http://www.nabble.com/High-packet-error-and-reception-problems-with-RFX-2400-t3522095.html</a><br />./benchmark_tx.py -f 2412M &#8211;bitrate 500k -v &#8211;tx-amplitude=30000<br />usrp_siggen.py and usrp_oscope.py<br />./benchmark_rx.py -f 2412M &#8211;bitrate 100k -v &#8211;rx-gain=75<br />&#8211;in digital folder<br /><br />2. <a href="http://staff.washington.edu/jon/gr-osx/gr-osx-usrp.html#using"> http://staff.washington.edu/jon/gr-osx/gr-osx-usrp.html#using</a><br />benchmark_usb.py Estimate throughput of USB<br />usrp_siggen.py Signal generator<br />usrp_oscope.py Oscilloscope (screenshot)<br />usrp_fft.py Spectrum analyzer (screenshot)</span></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
:]</div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/12/ways-to-keep-from-duplicating-path/">Ways to Keep From Duplicating Path Variable in Csh</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-12T00:00:00-05:00" pubdate data-updated="true">Oct 12<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
<pre class="prettyprint"><code><span class="com">#!/usr/bin/perl</span><span class="pln"><br /></span><span class="com">#</span><span class="pln"><br /></span><span class="com"># ^^ ensure this is pointing to the correct location.</span><span class="pln"><br /></span><span class="com">#</span><span class="pln"><br /></span><span class="com"># Title: &nbsp; &nbsp;SLimPath</span><span class="pln"><br /></span><span class="com"># Author: &nbsp; David "Shoe Lace" Pyke <eselle@users.sourceforge.net></eselle@users.sourceforge.net></span><span class="pln"><br /></span><span class="com"># &nbsp; : &nbsp; Tim Nelson </span><span class="pln"><br /></span><span class="com"># Purpose: To create a slim version of my envirnoment path so as to eliminate</span><span class="pln"><br /></span><span class="com"># &nbsp; &nbsp; &nbsp; duplicate entries and ensure that the "." path was last.</span><span class="pln"><br /></span><span class="com"># Date Created: April 1st 1999</span><span class="pln"><br /></span><span class="com"># Revision History:</span><span class="pln"><br /></span><span class="com"># &nbsp; 01/04/99: initial tests.. didn't wok verywell at all</span><span class="pln"><br /></span><span class="com"># &nbsp; &nbsp; &nbsp; : retreived path throught '$ENV' call</span><span class="pln"><br /></span><span class="com"># &nbsp; 07/04/99: After an email from Tim Nelson <wayland@ne.com.au> got it to</wayland@ne.com.au></span><span class="pln"><br /></span><span class="com"># &nbsp; &nbsp; &nbsp; &nbsp; work.</span><span class="pln"><br /></span><span class="com"># &nbsp; &nbsp; &nbsp; : used 'push' to add to array</span><span class="pln"><br /></span><span class="com"># &nbsp; &nbsp; &nbsp; : used 'join' to create a delimited string from a list/array.</span><span class="pln"><br /></span><span class="com"># &nbsp; 16/02/00: fixed cmd-line options to look/work better</span><span class="pln"><br /></span><span class="com"># &nbsp; 25/02/00: made verbosity level-oriented</span><span class="pln"><br /></span><span class="com">#</span><span class="pln"><br /></span><span class="com">#</span><span class="pln"><br /></span><span class="kwd">use</span><span class="pln"> </span><span class="typ">Getopt</span><span class="pun">::</span><span class="typ">Std</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">sub</span><span class="pln"> printlevel</span><span class="pun">;</span><span class="pln"><br /><br />$initial_str </span><span class="pun">=</span><span class="pln"> </span><span class="str">""</span><span class="pun">;</span><span class="pln"><br />$debug_mode </span><span class="pun">=</span><span class="pln"> </span><span class="str">""</span><span class="pun">;</span><span class="pln"><br />$delim_chr </span><span class="pun">=</span><span class="pln"> </span><span class="str">":"</span><span class="pun">;</span><span class="pln"><br />$opt_v </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"><br /><br />getopts</span><span class="pun">(</span><span class="str">"v:hd:l:e:s:"</span><span class="pun">);</span><span class="pln"><br /><br />OPTS</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; $opt_h </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\n$0 [-v level] [-d level] [-l delim] ( -e varname | -s strname | -h )"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\nWhere:"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\n &nbsp; -h &nbsp;This help"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\n &nbsp; -d &nbsp;Debug level"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\n &nbsp; -l &nbsp;Delimiter (between path vars)"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\n &nbsp; -e &nbsp;Specify environment variable (NB: don't include \$ sign)"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\n &nbsp; -s &nbsp;String (ie. $0 -s \$PATH:/looser/bin/)"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\n &nbsp; -v &nbsp;Verbosity (0 = quiet, 1 = normal, 2 = verbose)"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">exit</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">};</span><span class="pln"><br />&nbsp; &nbsp; $opt_d </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; printlevel </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="str">"You selected debug level $opt_d\n"</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; $debug_mode </span><span class="pun">=</span><span class="pln"> $opt_d</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">};</span><span class="pln"><br />&nbsp; &nbsp; $opt_l </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; printlevel </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="str">"You are going to delimit the string with \"$opt_l\"\n"</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; $delim_chr </span><span class="pun">=</span><span class="pln"> $opt_l</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">};</span><span class="pln"><br />&nbsp; &nbsp; $opt_e </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">$opt_s</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">die</span><span class="pln"> </span><span class="str">"Cannot specify BOTH env var and string\n"</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; printlevel </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Using Environment variable \"$opt_e\"\n"</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; $initial_str </span><span class="pun">=</span><span class="pln"> $ENV</span><span class="pun">{</span><span class="pln">$opt_e</span><span class="pun">};</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">};</span><span class="pln"><br />&nbsp; &nbsp; $opt_s </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; printlevel </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Using String \"$opt_s\"\n"</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; $initial_str </span><span class="pun">=</span><span class="pln"> $opt_s</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">};</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$</span><span class="com">#ARGV != 1) and !$opt_e and !$opt_s){</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">die</span><span class="pln"> </span><span class="str">"Nothing to work with -- try $0 -h\n"</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /><br />$what </span><span class="pun">=</span><span class="pln"> shift </span><span class="lit">@ARGV</span><span class="pun">;</span><span class="pln"><br /></span><span class="com"># Split path using the delimiter</span><span class="pln"><br /></span><span class="lit">@dirs</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> split</span><span class="pun">(</span><span class="str">/$delim_chr/</span><span class="pun">,</span><span class="pln"> $initial_str</span><span class="pun">);</span><span class="pln"><br /><br />$dest</span><span class="pun">;</span><span class="pln"><br /></span><span class="lit">@newpath</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">();</span><span class="pln"><br />LOOP</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="lit">@dirs</span><span class="pun">){</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="com"># Ensure the directory exists and is a directory</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pun">(!</span><span class="pln"> </span><span class="pun">-</span><span class="pln">e </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> printlevel </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="str">"$_ does not exist\n"</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="com"># If the directory is ., set $dot and go around again</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">$_ eq </span><span class="str">'.'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> $dot </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln"><br /></span><span class="com"># &nbsp; if ($_ ne `realpath $_`){</span><span class="pln"><br /></span><span class="com"># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printlevel 2, "$_ becomes ".`realpath $_`."\n";</span><span class="pln"><br /></span><span class="com"># &nbsp; }</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">undef</span><span class="pln"> $dest</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="com">#$_=Stdlib::realpath($_,$dest);</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="com"># Check for duplicates and dot path</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">foreach</span><span class="pln"> $adir </span><span class="pun">(</span><span class="lit">@newpath</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">$_ eq $adir</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> <br />&nbsp; &nbsp; &nbsp; &nbsp; printlevel </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Duplicate: $_\n"</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">next</span><span class="pln"> LOOP</span><span class="pun">;</span><span class="pln"> <br />&nbsp; &nbsp; </span><span class="pun">}}</span><span class="pln"><br /><br />&nbsp; &nbsp; push </span><span class="lit">@newpath</span><span class="pun">,</span><span class="pln"> $_</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="com"># Join creates a string from a list/array delimited by the first expression</span><span class="pln"><br /></span><span class="kwd">print</span><span class="pln"> join</span><span class="pun">(</span><span class="pln">$delim_chr</span><span class="pun">,</span><span class="pln"> </span><span class="lit">@newpath</span><span class="pun">)</span><span class="pln"> </span><span class="pun">.</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$dot </span><span class="pun">?</span><span class="pln"> $delim_chr</span><span class="pun">.</span><span class="str">".\n"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">);</span><span class="pln"><br /><br />printlevel </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Thank you for using $0\n"</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">exit</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">sub</span><span class="pln"> printlevel </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="kwd">my</span><span class="pun">(</span><span class="pln">$level</span><span class="pun">,</span><span class="pln"> $string</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">@_</span><span class="pun">;</span><span class="pln"><br /><br />&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">$opt_v </span><span class="pun">&gt;=</span><span class="pln"> $level</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> STDERR $string</span><span class="pun">;</span><span class="pln"><br />&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span></code></pre></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>
1,i love this company,it can link to baned web <br />2,you have to delete the links of my classmates!&gt;.&lt;</div>
</div>
</div>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/10/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/8/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/10/09/lte-reading-excerpt/">LTE reading excerpt</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/30/johnsons-algorithm/">All-pairs shortest path</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/15/more-freedom-in-doing-things/">More freedom in doing things</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/10/reading-note-of-sicp-4/">Reading note of SICP (4)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/08/reading-note-of-sicp-3/">Reading note of SICP (3)</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  <a href="https://github.com/creasyw">Qiong Wu</a> &copy;2009-2013 &mdash;
  <span class="credit">Thanks to <a href="http://ayyang.com">Alex Yang</a>, <a href="http://octopress.org/">Octopress</a> and <a href="https://github.com/">Github</a>.</span><br>
  send me an email 
<script type="text/javascript">
var emailriddlerarray=[99,114,101,97,115,121,119,117,113,105,111,110,103,64,103,109,97,105,108,46,99,111,109]
var encryptedemail_id82='' //variable to contain encrypted email 
for (var i=0; i<emailriddlerarray.length; i++)
 encryptedemail_id82+=String.fromCharCode(emailriddlerarray[i])
 document.write('<a href="mailto:'+encryptedemail_id82+'"><img src="/img/email.png" alt="Qiong" /></a>')
</script>
</p>
</footer>
</body>
</html>
