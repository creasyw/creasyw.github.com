
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Qiong Wu</title>
  <meta name="author" content="Qiong Wu">

  
  <meta name="description" content="I am still familiar with the highlighted view for differences rather than the &#8220;diff&#8221; command, which produces the results in a &#8220 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://creasyw.github.io/blog/page/7/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <!-- add Mathjex.js by qiong -->
  <script src="http://kramdown.rubyforge.org/MathJax/MathJax.js" type="text/javascript"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="./atom.xml" rel="alternate" title="Qiong Wu" type="application/atom+xml">
  
  <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  
  
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Qiong Wu</a></h1>
  <!--
  
    <h2>A blogging framework for hackers.</h2>
  
  -->
</hgroup>
</header>
  <nav role="navigation"><!--
<ul class="subscription" data-subscription="rss">
  <li><a href="./atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:creasyw.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

-->

<ul class="main-navigation">
  <!--<li><a class="yellow" href="/">Hello</a></li>-->
  <li><a class="github" href="/blog/archives/">Blog</a></li>
  <li><a class="github" href="/tags">Tags</a></li>
  <li><a class="github" href="http://www.github.com/creasyw">Github</a></li>
  <li><a class="github" href="https://twitter.com/creasywuqiong">Twitter</a></li>
  <li><a class="github" href="/rss">RSS</a></li>
</ul>


</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/06/comparing-file-diff-in-ubuntu/">Comparing File Diff in Ubuntu</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-06T00:00:00-05:00" pubdate data-updated="true">Mar 6<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
I am still familiar with the highlighted view for differences rather than the &#8220;diff&#8221; command, which produces the results in a &#8220;+/-&#8221; form. After a easy google, the Meld turns out be one good alternative solution for this purpose. <a href="http://meld.sourceforge.net/">Here</a> is its web page.<br /><br />Just one step to do:<br />$ sudo apt-get install meld<br /><br />Then, you will find the Meld in Application-&gt;Programming directory.<br /><br /><br />Have fun.</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/04/some-basic-cc-questions/">Some Basic C/C++ Questions</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-04T00:00:00-05:00" pubdate data-updated="true">Mar 4<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
<span id="internal-source-marker_0.4999975798251227" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">1) What are some of the main differences between a linked list and an array?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are faster in access than a link list for random access with index.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are not dynamic while a link list is.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are easier to sort than a link list.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The elements of link list can be deleted/inserted while arrays cannot.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays occupy the same block of memory, while a link list is distributed.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Array objects are automatically created by a compiler, while link lists are not.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are part of most compilers, while link lists are not.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are syntactically simple to read.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">2) What are the differences between struct, class and union?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Struct,  class and union all contain data members and methods. However, a struct  and union have their member’s public by default, while the class  members are private by default. Also, a struct cannot contain an  instance of itself. A union cannot be used as a base class in  inheritance. None of a union&#8217;s data members can be declared static and  none of its functions can be virtual.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">3) What are virtual functions?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Virtual  functions are functions whose behavior is known at runtime rather than  at compile time. Due to this behavior, it can be said that virtual  functions implement Polymorphism. In other words, preceding a function  name with virtual in the base class means that that function is intended  to be re-implemented (overridden) in the sub-class.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">4) Explain the mechanism of virtual functions and virtual function tables.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Whenever  a class member function is declared as virtual, the compiler creates a  virtual table in memory which contains all function pointers that are  declared as virtual in that class. This enables run time polymorphism  (i.e. finding out the desired function at run time). Virtual function  tables also have an additional pointer in the object to the vtable. As  this additional pointer and the vtable increases the size of the object,  a class designer needs to be judicious about declaring functions  virtual. The sequence of events upon calling a method on the base object  pointer is:</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Get vtable pointer (this vtable pointer points to the beginning of the vtable).</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Get the function pointers in the vtable using offset.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Invoke the function indirectly through the vtable pointer.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">5) Given a singly linked list and a pointer to a certain node in the list, how would you delete that node in constant time?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">First  of all, check if this node is the last node in the list. If not, copy  the contents of the next node to the current node, and delete the next  node.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">6) What are recursive functions? What are the advantages and disadvantages of recursive algorithms?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  function that calls itself repeatedly, satisfying some condition, is  called a Recursive Function. In my point of view, the recursive  functions should be avioded at most of the time via the &#8220;while&#8221; loop  sentence. However, on the other hand, some problems inherently are  better suited for recursion, such as Fibonacci series generation.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Some  advantages of recursive algorithms are: concise in terms of source  code; and looking more elegant. The disadvantages of recursion include:  requiring more of stack than non-recursive algorithms, due to several  activation stacks for each call of the function; and correcting or  testing recursive functions would require a lot of careful thinking.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">7) What leads to code-bloating in C++?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Inline  functions and templates, if not used properly, may lead to code  bloating. Multiple Inheritance may also lead to code bloating (this is  because the sub classes will end up getting members from all the base  classes even if only few members will suffice).</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Inline  is great. Reasons: They look like functions, they act like functions,  they&#8217;re ever so much better than macros (Whenever you write a macro, you  have to remember to parenthesize all the arguments in the macro body.  Otherwise you can run into trouble when somebody calls the macro with an  expression. On the contrary, inline funtions do not have that kind of  troubles), and you can call them without having to incur the overhead of  a function call. Moreover, as inlining a function, it may enable  compilers to perform context-specific optimizations on the body of the  function. Most compilers never perform such optimizations on &#8220;outlined&#8221;  function calls.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">However,  the idea behind an inline function is to replace each call of that  function with its code body, which is likely to increase the size of  your object code. On machines with limited memory, overzealous inlining  can give rise to programs that are too big for the available space. Even  with virtual memory, inline-induced code bloat can lead to additional  paging, a reduced instruction cache hit rate, and the performance  penalties that accompany these things.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Solution:  Initially, don&#8217;t inline anything, or at least limit your inlining to  those functions that must be inline (eg. functions defined inside a  class which are implicitly declared inline) or are truly trivial (such  as Person::age). By employing inlines cautiously, you facilitate your  use of a debugger, but you also put inlining in its proper place: as a  hand-applied optimization. Don&#8217;t forget the empirically determined rule  of 80-20, which states that a typical program spends 80% of its time  executing only 20% of its code. It&#8217;s an important rule, because it  reminds you that your goal as a software developer is to identify the  20% of your code that can increase your program&#8217;s overall performance.  You can inline and otherwise tweak your functions until the cows come  home, but it&#8217;s wasted effort unless you&#8217;re focusing on the right  functions.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">8) What are references in C++? Why do you need them when you have pointers?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Reference  variables are internally implemented as a pointer; it’s just that  programmers can&#8217;t use it the way they use pointers. As a side note, a  reference must refer to some object at all times, but a pointer can  point to NULL. In this way, references can be more efficient when you  know that you&#8217;ll always have an object to point to, because you don&#8217;t  have to check against NULL.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">9)  How do you do dynamic memory allocation in C applications? List  advantages and disadvantages of dynamic memory allocation vs. static  memory allocation.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">In C, malloc, calloc and realloc are used to allocate memory dynamically. In C++, new(), is usually used to allocate objects.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Advantage  is that memory is allocated on an as-needed basis, which helps remove  the inefficiencies inherent to static memory allocation, that is when  the amount of memory needed is not known at compile time and one has to  make a guess.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Disadvantages:  1) dynamic memory allocation is slower than static memory allocation,  because dynamic memory allocation happens in the heap area; 2) dynamic  memory needs to be carefully deleted after use, because they are created  in non-contiguous area of memory segment, and if not properly handled,  the operations would cause memory fragmentation; 3) dynamic memory  allocation causes contention between threads, so it degrades performance  when it happens in a thread.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">10) What are constructors and destructors?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Constructors and destructors are provisions for initialization and cleanup of objects.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  constructor is a special member function with the same name as the  Class. It is invoked automatically when the object is created. It  usually contains initialization code for member variables and allocation  of memory. There can be multiple overloaded constructors, with  different input arguments, used to initialize the object in a variety of  ways.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  destructor is a special member function that is called just before an  object is destroyed. For example, when the object variable goes out of  scope. It is used to perform cleanup. There can be only one destructor.  Its name is ‘~’ followed by the class name.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">11) What happens if an error occurs in a constructor or destructor?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Constructors  don&#8217;t have a return type, so it&#8217;s not possible to use error codes. The  best way to signal constructor failure is therefore to throw an  exception. However, keep in mind that the memory for the object itself  is released, and the destructors for all sub-objects (i.e. members and  base classes) whose constructors have successfully run to completion  will be called, which will consquently cause memory leak by the object  pointer.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">12) Differentiate between a copy constructor and an assignment operator.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  copy constructor is used to copy an object to a newly created object.  This is used during initialization and not during ordinary assignment.  The copy constructor is invoked whenever a new object is created and  initialized to an existing object of the same kind.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">In  other words, the assignment operator handles assigning one object to  another of the same class. If a statement creates a new object it is  using initialization. If it alters the value of an existing object it is  assignment.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">13) What are virtual destructors?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Destructor  implemented by declaring a base class’s destructor with the keyword  virtual is called a virtual destructor. A virtual destructor ensures  that, when delete is applied to a base class pointer or reference, it  calls the destructor implemented in the derived class, if an  implementation exists.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Let’s  take the simplest polymorphic relation: A - base class, B - class  derived from A. If we&#8217;ve got a pointer (or reference) to class A, but  under the hood it is an object of type B, and we&#8217;re trying to delete the  object, declaration of virtual destructor in class A ensures that the  destructor of class B will be called.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">B* b = new B;</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A* a = b //due to polymorphism!</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">delete a; // both A and B destructors are called.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">14)  What is multiple inheritance? What are the potential pitfalls of  multiple inheritance? How would you avoid multiple inheritance?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Deriving  a class from more than one direct base class is called multiple  inheritance. Note that the order of derivation is relevant only to  determine the order of default initialization by constructors and  cleanup by destructors.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Potential  pitfalls of Multiple Inheritance are: 1) Ambiguity; 2) slow; 3) The  “Common Ancestor” problem: For example, if class B and class C derived  from class A and if class D derived from class B and class C, then class  D will have 2 copies of class A that might lead to inconsistency, as  the class doesn&#8217;t know which copy it is viewing.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">15) What is exception handling? What are the advantages of exception handling?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Exceptions  are an alternative to function return values. The big differences are:  1) Exceptions cannot be ignored. They must be caught or the app will  crash. It is a way of forcing the caller of a function to deal with an  exceptional condition. 2) It is also an improvement over return values,  because you can put all possible values of your return type to good use,  instead of having to dedicate one or more values as the &#8220;invalid&#8221;  value. 3) In addition, exceptions allow you to jump out of deeply nested  function calls conveniently, avoiding a lot of return type checking and  conditional statements.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">16) What is the difference between new()/delete() and malloc()/free ()?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  main difference is that malloc() and free() don&#8217;t know anything about  constructors and destructors, where as new and delete do. The following  lists the main differences: 1) new automatically computes the size of  the data object. In malloc you would have to use the sizeof operator. 2)  new automatically returns the correct pointer type. In malloc you would  have to use a type cast. 3) with new you can initialize the object  while creating the object. 4) new and delete can be overloaded. 5) It&#8217;s  safe to delete a NULL pointer, but you&#8217;ll get core dump to free a NULL  pointer.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">17) Describe different types of polymorphism available in C++.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">1.  Compile time polymorphism; 2. Runtime Polymorphism. Operator  overloading and Function Overloading are the examples for compile time  polymorphism. Using Virtual Functions we will achieve run time  polymorphism.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Computer Network</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  Internet Protocol (IP) is a key part of the mechanism for transferring  data across the internet. Information is broken into small packets, and  the IP is responsible for relaying and routing them around the system by  identifying and locating hosts. The current version is IPv4, and  because it is made up in sets of 32 bits, it is limited to having just  under 4.3 billion addresses. It seems like a lot but they are almost all  used up.</span></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/03/xml-is-dumb-format-for-storing-data/">XML Is a Dumb Format for Storing Data</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-03T00:00:00-05:00" pubdate data-updated="true">Mar 3<span>rd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
originally wrote by&nbsp;<a href="http://www.joelonsoftware.com/articles/fog0000000296.html">Joel Spolsky</a> <br /><br />I&#8217;m not sure why XML got so sexy. It has its advantages; it&#8217;s sure a good idea for data interchange or for all those little files you need to store settings. But for real work it just can&#8217;t do what a solid, multiuser, relational database can do. The next time some uninformed analyst at Gartner or Giga or Forrester tells you &#8220;in the future, everything will be XML,&#8221; ask them how to do &#8220;SELECT author FROM books&#8221; fast with XML. Hint: you can&#8217;t. It has to be slow. XML is not the way to store a lot of data. Now tell me how to insert a new book at the beginning of the table without massive bitblts. Of course, I doubt if there is an analyst in one of those companies who would even understand that sentence, but that&#8217;s life. Now lets look at the books table in XML.<br /><br />&lt;?xml blah blah&gt;<br />&lt;books&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;book&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;UI Design for Programmers&lt;/title&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;author&gt;Joel Spolsky&lt;/author&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;/book&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;book&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;The Chop Suey Club&lt;/title&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;author&gt;Bruce Weber&lt;/author&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;/book&gt;<br />&lt;/books&gt;<br /><br />Quick question. What is the code to move to the next record?<br /><br />Uh&#8230;<br /><br />At this point a good programmer would say, well, let&#8217;s parse the XML into a tree in memory so that we can operate on it reasonably quickly. The amount of work that has to be done here by the CPU to SELECT author FROM books will bore you absolutely to tears. As every compiler writer knows, lexing and parsing are the slowest part of compiling. Suffice it to say that it involves a lot of string stuff, which we discovered is slow, and a lot of memory allocation stuff, which we discovered is slow, as we lex, parse, and build an abstract syntax tree in memory. That assumes that you have enough memory to load the whole thing at once. With relational databases, the performance of moving from record to record is fixed and is, in fact, one CPU instruction. That&#8217;s very much by design. And thanks to memory mapped files you only have to load the pages of disk that you are actually going to use. With XML, if you preparse, the performance of moving from record to record is fixed but there&#8217;s a huge startup time, and if you don&#8217;t preparse, the performance of moving from record to record varies based on the length of the record before it and is still hundreds of CPU instructions long.<br /><br />What this means to me is that you can&#8217;t use XML if you need performance and have lots of data. If you have a little bit of data, or if what you&#8217;re doing doesn&#8217;t have to be fast, XML is a fine format. And if you really want the best of both worlds, you have to come up with a way to store metadata next to your XML, something like Pascal strings&#8217; byte count, which give you hints about where things are in the file so that you don&#8217;t have to parse and scan for them. But of course then you can&#8217;t use text editors to edit the file because that messes up the metadata, so it&#8217;s not really XML anymore.<br /><br />&#8212;&#8212; <br />By the way, when I published this digest from Joel, I have no idea how to put the HTML code in my blog contents. Here is the <a href="http://www.digipassion.com/2009/02/writing-html-code-inside-post.html">solution</a>, and the full table of escape characters are <a href="http://www.theukwebdesigncompany.com/articles/entity-escape-characters.php">here</a>.</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/03/interview-at-point-of-interviewer/">Interview at the Point of Interviewer</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-03T00:00:00-05:00" pubdate data-updated="true">Mar 3<span>rd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
also comes from&nbsp;<a href="http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html">Joel on software</a> <br /><br />How do you detect smart in an interview? The first good sign is that you don’t have to explain things over and over again. The conversation just flows. Often, the candidate says something that shows real insight, or brains, or mental acuity. So an important part of the interview is creating a situation where someone can show you how smart they are. Remember, smart does not mean “knows the answer to trivia questions.” Anyway, software teams want to hire people with aptitude, not a particular skill set. Any skill set that people can bring to the job will be technologically obsolete in a couple of years, anyway, so it’s better to hire people that are going to be able to learn any new technology rather than people who happen to know how to make JDBC talk to a MySQL database right this minute. In general, the way to learn the most about a person is to let them do the talking. Give them open-ended questions and problems.<br /><br />That’s just a list of questions that I want to ask. Here’s a typical plan for interviewing a programmer:<br /><br />1. Introduction<br />2. Question about recent project candidate worked on<br />3. Easy Programming Question<br />4. Pointer/Recursion Question<br />5. Are you satisfied?<br />6. Do you have any questions? <br /><br />What should you look for during the open ended questions?<br /><br />One: Look for passion. Smart people are passionate about the projects they work on. They get very excited talking about the subject. They talk quickly, and get animated. Being passionately negative can be just as good a sign. “My last boss wanted to do everything on VAX computers because it was all he understood. What a dope!” There are far too many people around that can work on something and not really care one way or the other. It’s hard to get people like this motivated about anything.<br /><br />Bad candidates just don’t care and will not get enthusiastic at all during the interview. A really good sign that a candidate is passionate about something is that when they are talking about it, they will forget for a moment that they are in an interview. Sometimes a candidate comes in who is very nervous about being in an interview situation—this is normal, of course, and I always ignore it. But then when you get them talking about Computational Monochromatic Art they will get extremely excited and lose all signs of nervousness. Good. I like passionate people who really care. (To see an example of Computational Monochromatic Art try unplugging your monitor.) You can challenge them on something (try it—wait for them to say something that’s probably true and say “that couldn’t be true”) and they will defend themselves, even if they were sweating five minutes ago, because they care so much they forget that you are going to be making Major Decisions About Their Life soon.<br /><br />Two: Good candidates are careful to explain things well, at whatever level. I have rejected candidates because when they talked about their previous project, they couldn’t explain it in terms that a normal person could understand. Often CS majors will just assume that everyone knows what Bates Theorem is or what O(log n) means. If they start doing this, stop them for a minute and say, “could you do me a favor, just for the sake of the exercise, could you please explain this in terms my grandmother could understand.” At this point many people will still continue to use jargon and will completely fail to make themselves understood. Gong! You don’t want to hire them, basically, because they are not smart enough to comprehend what it takes to make other people understand their ideas.<br /><br />Three: If the project was a team project, look for signs that they took a leadership role. A candidate might say, “We were working on X, but the boss said Y and the client said Z.” I’ll ask, “So what did you do?” A good answer to this might be “I got together with the other members of the team and wrote a proposal…” A bad answer might be, “Well, there was nothing I could do. It was an impossible situation.” Remember, Smart and Gets Things Done. The only way you’re going to be able to tell if somebody Gets Things Done is to see if historically they have tended to get things done in the past. In fact, you can even ask them directly to give you an example from their recent past when they took a leadership role and got something done—overcoming some institutional inertia, for example.<br /><br />Most of the time in the interview, though, should be spent letting the candidate prove that they can write code. Reassure candidates that you understand that it’s hard to write code without an editor, and you will forgive them if the whiteboard gets really messy. Also you understand that it’s hard to write bug-free code without a compiler, and you will take that into account.<br /><br />These softball questions seem too easy, so when I first started asking them, I had to admit that I really expected everyone to sail right through them. What I discovered was that everybody solved the problem, but there was a lot of variation in how long it took them to solve. That reminded me of why I couldn’t trade bonds for a living (http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html), which means that if the basic concepts aren’t so easy that you don’t even have to think about them, you’re not going to get the big concepts. You see, if you can’t whiz through the easy stuff at 100 m.p.h., you’re never gonna get the advanced stuff.<br /><br />15 years of experience interviewing programmers has convinced me that the best programmers all have an easy aptitude for dealing with multiple levels of abstraction simultaneously. In programming, that means specifically that they have no problem with recursion (which involves holding in your head multiple levels of the call stack at the same time) or complex pointer-based algorithms (where the address of an object is sort of like an abstract representation of the object itself). Furthermore, I’ve come to realize that understanding pointers in C is not a skill, it’s an aptitude. Pointers require a complex form of doubly-indirected thinking that some people just can’t do, and it’s pretty crucial to good programming. A lot of the “script jocks” who started programming by copying JavaScript snippets into their web pages and went on to learn Perl never learned about pointers, and they can never quite produce code of the quality you need.<br /><br />That’s the source of all these famous interview questions you hear about, like “reversing a linked list” or “detect loops in a tree structure.” Even though the format of the interview is, superficially, just a candidate writing some code on the whiteboard, my real goal here is to have a conversation about it. “Why did you do it that way?” “What are the performance characteristics of your algorithm?” “What did you forget?” “Where’s your bug?”<br /><br />That means I don’t really mind giving programming problems that are too hard, as long as the candidate has some chance of starting out, and then I’m happy to dole out little hints along the way, little toeholds, so to speak. I might ask someone, say, to project a triangle onto a plane, a typical graphics problem, and I don’t mind helping them with the trig (SOH-CAH-TOA, baby!), and when I ask them how to speed it up, I might drop little hints about look-up tables. Notice that the kinds of hints I’m happy to provide are really just answers to trivia questions—the kinds of things that you find on Google.<br /><br />Inevitably, you will see a bug in their function. So we come to question five from my interview plan: “Are you satisfied with that code?” You may want to ask, “OK, so where’s the bug?” The quintessential Open Ended Question From Hell. All programmers make mistakes, there’s nothing wrong with that, they just have to be able to find them. With string functions in C, most college kids forget to null-terminate the new string. With almost any function, they are likely to have off-by-one errors. They will forget semicolons sometimes. Their function won’t work correctly on 0 length strings, or it will GPF if malloc fails… Very, very rarely, you will find a candidate that doesn’t have any bugs the first time. In this case, this question is even more fun. When you say, “There’s a bug in that code,” they will review their code carefully, and then you get to see if they can be diplomatic yet firm in asserting that the code is perfect.</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/02/some-advices/">Some Advices About Low-level Programming</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-02T00:00:00-05:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
see also &lt;<a href="http://www.joelonsoftware.com/articles/fog0000000319.html">Back to Basic</a>&gt;<br />reference &lt;<a href="http://www.joelonsoftware.com/articles/CollegeAdvice.html">Advice for Computer Science College Students</a>&gt;<br /><br /><br />Learn how to write<br /><br />The difference between a tolerable programmer and a great programmer is not how many programming languages they know, and it&#8217;s not whether they prefer Python or Java. It&#8217;s whether they can communicate their ideas. By persuading other people, they get leverage. By writing clear comments and technical specs, they let other programmers understand their code, which means other programmers can use and work with their code instead of rewriting it. Absent this, their code is worthless. By writing clear technical documentation for end users, they allow people to figure out what their code is supposed to do, which is the only way those users can see the value in their code. There&#8217;s a lot of wonderful, useful code buried on sourceforge somewhere that nobody uses because it was created by programmers who don&#8217;t write very well (or don&#8217;t write at all), and so nobody knows what they&#8217;ve done and their brilliant code languishes.<br /><br />If you can write, wherever you get hired, you&#8217;ll soon find that you&#8217;re getting asked to write the specifications and that means you&#8217;re already leveraging your influence and getting noticed by management. Start a journal or weblog. The more you write, the easier it will be, and the easier it is to write, the more you&#8217;ll write, in a virtuous circle.<br /><br />Learn C<br /><br />C. Notice I didn&#8217;t say C++. Although C is becoming increasingly rare, it is still the lingua franca of working programmers. It is the language they use to communicate with one another, and, more importantly, it is much closer to the machine than &#8220;modern&#8221; languages that you&#8217;ll be taught in college like ML, Java, Python, whatever trendy junk they teach these days. You need to spend at least a semester getting close to the machine or you&#8217;ll never be able to create efficient code in higher level languages. You&#8217;ll never be able to work on compilers and operating systems, which are some of the best programming jobs around. You&#8217;ll never be trusted to create architectures for large scale projects. I don&#8217;t care how much you know about continuations and closures and exception handling: if you can&#8217;t explain why &#8220;while (*s++ = *t++);&#8221; copies a string, or if that isn&#8217;t the most natural thing in the world to you, well, you&#8217;re programming based on superstition, as far as I&#8217;m concerned: a medical doctor who doesn&#8217;t know basic anatomy, passing out prescriptions based on what the pharma sales babe said would work.<br /><br />some special cases to indicate this point<br />char bigString[1000];&nbsp;&nbsp;&nbsp;&nbsp; /* I never know how much to allocate&#8230; */ <br />bigString[0] = &#8216;\0&#8217;;<br />strcat(bigString,&#8221;John, &#8220;);<br />strcat(bigString,&#8221;Paul, &#8220;); <br />strcat(bigString,&#8221;George, &#8220;); <br />strcat(bigString,&#8221;Joel &#8220;);<br /><br />The time consumption will increase as the n^2, where n indicates the number of characters that have already in the char array, for the reason that every time the strcat will begin to search at the beginning of the array. To reduce the runtime decrease as linear as input number of values:<br />char* mystrcat( char* dest, char* src ) <br />{<br />&nbsp;&nbsp;&nbsp;&nbsp; while (*dest) dest++; <br />&nbsp;&nbsp;&nbsp;&nbsp; while (*dest++ = *src++);<br />&nbsp;&nbsp;&nbsp;&nbsp; return &#8211;dest;<br />}<br />char bigString[1000];&nbsp;&nbsp;&nbsp;&nbsp; /* I never know how much to allocate&#8230; */<br />char *p = bigString; <br />bigString[0] = &#8216;\0&#8217;; <br />p = mystrcat(p,&#8221;John, &#8220;);<br />p = mystrcat(p,&#8221;Paul, &#8220;); <br />p = mystrcat(p,&#8221;George, &#8220;);<br />p = mystrcat(p,&#8221;Joel &#8220;);<br /><br />The designers of Pascal were aware of this problem and &#8220;fixed&#8221; it by storing a byte count in the first byte of the string. These are called Pascal Strings. They can contain zeros and are not null terminated. Because a byte can only store numbers between 0 and 255, Pascal strings are limited to 255 bytes in length, but because they are not null terminated they occupy the same amount of memory as ASCIZ strings. The great thing about Pascal strings is that you never have to have a loop just to figure out the length of your string. Finding the length of a string in Pascal is one assembly instruction instead of a whole loop. It is monumentally faster.<br /><br />The old Macintosh operating system used Pascal strings everywhere. Many C programmers on other platforms used Pascal strings for speed. Excel uses Pascal strings internally which is why strings in many places in Excel are limited to 255 bytes, and it&#8217;s also one reason Excel is blazingly fast.<br /><br />For a long time, if you wanted to put a Pascal string literal in your C code, you had to write:<br /><br />char* str = &#8220;\006Hello!&#8221;;<br /><br />Yep, you had to count the bytes by hand, yourself, and hardcode it into the first byte of your string. Lazy programmers would do this, and have slow programs:<br /><br />char* str = &#8220;*Hello!&#8221;;<br />str[0] = strlen(str) - 1;<br /><br />Notice in this case you&#8217;ve got a string that is null terminated (the compiler did that) as well as a Pascal string. I used to call these fucked strings because it&#8217;s easier than calling them null terminated pascal strings but this is a rated-G channel so you will have use the longer name.<br /><br />Well, since we&#8217;re looking at the bits today I shouldn&#8217;t have ignored this. I should have done this correctly: figured out how many bytes I needed and allocated the right amount of memory. Shouldn&#8217;t I have?<br /><br />Because otherwise, you see, a clever hacker will read my code and notice that I&#8217;m only allocating 1000 bytes and hoping it will be enough, and they&#8217;ll find some clever way to trick me into strcatting a 1100 byte string into my 1000 bytes of memory, thus overwriting the stack frame and changing the return address so that when this function returns, it executes some code which the hacker himself wrote. This is what they&#8217;re talking about when they say that a particular program has a buffer overflow susceptibility. It was the number one cause of hacks and worms in the olden days before Microsoft Outlook made hacking easy enough for teenagers to do.<br /><br />(bold malloc&#8230;)How does the malloc work? The nature of malloc is that it has a long linked list of available blocks of memory called the free chain. When you call malloc, it walks the linked list looking for a block of memory that is big enough for your request. Then it cuts that block into two blocks &#8211; one the size you asked for, the other with the extra bytes, and gives you the block you asked for, and puts the leftover block (if any) back into the linked list. When you call free, it adds the block you freed onto the free chain. Eventually, the free chain gets chopped up into little pieces and you ask for a big piece and there are no big pieces available the size you want. So malloc calls a timeout and starts rummaging around the free chain, sorting things out, and merging adjacent small free blocks into larger blocks. This takes 3 1/2 days. The end result of all this mess is that the performance characteristic of malloc is that it&#8217;s never very fast (it always walks the free chain), and sometimes, unpredictably, it&#8217;s shockingly slow while it cleans up. (This is, incidentally, the same performance characteristic of garbage collected systems, surprise surprise, so all the claims people make about how garbage collection imposes a performance penalty are not entirely true, since typical malloc implementations had the same kind of performance penalty, albeit milder.)<br /><br />Smart programmers minimize the potential distruption of malloc by always allocating blocks of memory that are powers of 2 in size. You know, 4 bytes, 8 bytes, 16 bytes, 18446744073709551616 bytes, etc. For reasons that should be intuitive to anyone who plays with Lego, this minimizes the amount of weird fragmentation that goes on in the free chain. Although it may seem like this wastes space, it is also easy to see how it never wastes more than 50% of the space. So your program uses no more than twice as much memory as it needs to, which is not that big a deal. Furthermore, when you call realloc, you should always double the size of memory that was previously allocated. That means that you never have to call realloc more than lg n times, which has decent performance characteristics even for huge strings, and you never waste more than 50% of your memory.</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/03/01/tree-search-algorithm-cont/">Tree Search Algorithm (Cont.)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-01T00:00:00-05:00" pubdate data-updated="true">Mar 1<span>st</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
&nbsp;The previous post is <a href="http://creasywuqiong.blogspot.com/2011/02/tree-search-algorithms.html">here</a><br />============ <br />struct treeNode{<br />&nbsp;&nbsp;&nbsp; int element;<br />&nbsp;&nbsp;&nbsp; struct treeNode *left;<br />&nbsp;&nbsp;&nbsp; struct treeNode *right;<br />}:<br />typedef struct treeNode *searchTree;<br /><br /><br />searchTree makeEmpty(searchTree T){<br />&nbsp;&nbsp;&nbsp; if(T!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MakeEmpty(T-&gt;left);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MakeEmpty(T-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; free(T);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return NULL;<br />}<br /><br /><br />searchTree findVal(int val, searchTree T){<br />&nbsp;&nbsp;&nbsp; if(T==NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; if(val<t->element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return findVal(val, T-&gt;left);<br />&nbsp;&nbsp;&nbsp; else if(val&gt;T-&gt;element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return findVal(val, T-&gt;right);<br />&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return T;<br />}<br /><br /><br />searchTree findMin(searchTree T){<br />&nbsp;&nbsp;&nbsp; if(T!=NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while(T-&gt;left!=NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = T-&gt;left;<br />&nbsp;&nbsp;&nbsp; return T;<br />}<br /><br /><br />searchTree insertVal(int val, searchTree T){<br />&nbsp;&nbsp;&nbsp; if(T==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T=(searchTree)malloc(sizeof(struct treeNode));<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(T==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf(&#8220;Error! There is no new memory to allocate.\n&#8221;);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; exit(0);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;element = val;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;left = T-&gt;right = NULL;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(val<t->element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;left = insertVal(val, T-&gt;left);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if(val&gt;T-&gt;element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;right = insertVal(val, T-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf(&#8220;The element has already in this tree.\n&#8221;);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return T;<br />}<br /><br /><br />searchTree deleteVal( int val, searchTree T){<br />&nbsp;&nbsp;&nbsp; searchTree temp;<br />&nbsp;&nbsp;&nbsp; if(T==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf(&#8220;The element is not found.\n&#8221;);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else if(val<t->element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;left = deleteVal(val, T-&gt;left);<br />&nbsp;&nbsp;&nbsp; else if(val&gt;T-&gt;element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;right = deleteVal(val, T-&gt;right);<br />&nbsp;&nbsp;&nbsp; else{&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // here, find the specific element<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(T-&gt;left &amp;&amp; T-&gt;right){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = findMin(T-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;element = tmp-&gt;element;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;right = deleteVal(tmp-&gt;element, T-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = T;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(T-&gt;left == NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = T-&gt;right;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if(T-&gt;right==NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = T-&gt;left;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; free(temp);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return T;<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br />// the functions below returns node which element is closest<br />// and larger in the Tree. We could call it &#8220;next&#8221;<br />// assumption1: the inputs are inquiry val and the root node<br />searchTree nextLarger(int val, searchTree T){<br />&nbsp;&nbsp;&nbsp; searchTree temp;<br />&nbsp;&nbsp;&nbsp; if(T==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf(&#8220;There is no tree.\n&#8221;);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; if(val<t->element){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(T-&gt;left!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = T-&gt;left;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while(val<temp->element &amp;&amp; temp-&gt;left!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = temp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = temp-&gt;left;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // This case indicate &#8220;temp-&gt;left==NULL&#8221; causes stop<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // so temp should be the return value<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(val<temp->element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = temp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // otherwise, result might in a new right tree<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // . or the parent node in this layer<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (temp-&gt;right!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = nextLarger(val, temp-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (temp!=NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = temp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return T;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while(val&gt;=T-&gt;element &amp;&amp; T-&gt;right!=NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = T-&gt;right;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(val<t->element){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = nextLarger(val, T);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return T;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br /><br />// assumption2: the input value is a given node in the tree.<br />// In this case, we might have to trace back.<br />// As a resutl, the original struct needs a little modification<br />struct treeNode{<br />&nbsp;&nbsp;&nbsp; int element;<br />&nbsp;&nbsp;&nbsp; struct treeNode *left;<br />&nbsp;&nbsp;&nbsp; struct treeNode *right;<br />&nbsp;&nbsp;&nbsp; struct treeNode *parenet;&nbsp;&nbsp;&nbsp; // to trace back<br />}:<br />typedef struct treeNode *searchTree;<br /><br />searchTree nextLarger2(searchTree start){<br />&nbsp;&nbsp;&nbsp; searchTree temp, record;<br />&nbsp;&nbsp;&nbsp; if(start==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf(&#8220;There is not a valid input.\n&#8221;);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; if(start-&gt;right!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start = findMin(start-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return start;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else if(start-&gt;parent!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(start == start-&gt;parent-&gt;left)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return start;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while(start-&gt;parent!=NULL &amp;&amp; start!=start-&gt;parent-&gt;left)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start = start-&gt;parent;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(start==start-&gt;parent-&gt;left)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return start;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />}</t-></temp-></temp-></t-></t-></t-></t-><br /><t-><t-><t-><t-><temp-><temp-><t-><br /></t-></temp-></temp-></t-></t-></t-></t-><br /><t-><t-><t-><t-><temp-><temp-><t-> // references: &lt;<a href="http://www.amazon.com/Introduction-Algorithms-Third-Thomas-Cormen/dp/0262033844/ref=sr_1_1?ie=UTF8&amp;qid=1299041213&amp;sr=8-1">Introduction to algorithms</a>&gt;, &lt;<a href="http://www.amazon.com/Cracking-Coding-Interview-Fourth-Programming/dp/145157827X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1299041239&amp;sr=1-1">Coding Interviews</a>&gt; </t-></temp-></temp-></t-></t-></t-></t-><br /><br /><t-><t-><t-><t-><temp-><temp-><t->// I just did some terrible interviews these days. Yes, some, and terrible.<br />// So, I wanna record everything here,&nbsp;</t-></temp-></temp-></t-></t-></t-></t-><br /><t-><t-><t-><t-><temp-><temp-><t->// no matter how stupid and rudimentary it is.<br />// Also as a means to push myself, everyday a step further.<br /></t-></temp-></temp-></t-></t-></t-></t-></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/02/28/tree-search-algorithms/">Tree Search Algorithms</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-02-28T00:00:00-05:00" pubdate data-updated="true">Feb 28<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
// Breadth-First Search <br />// The tricky part is that we have to know the entire info. about <br />// the graph, which indicates in the link-matrix graphmatrix <br /><br />struct node{ <br />&nbsp;&nbsp; &nbsp;int color;&nbsp;&nbsp; &nbsp;// 0-white, 1-grey, 2-black <br />&nbsp;&nbsp; &nbsp;int index;&nbsp;&nbsp; &nbsp;// fount order <br />&nbsp;&nbsp; &nbsp;int d; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// distance to the root <br />&nbsp;&nbsp; &nbsp;struct node *parent; <br />}; <br />typedef struct node* Node; <br /><br />void buildBFS1(int *graphmatrix, Node graph, Node start){ <br />&nbsp;&nbsp; &nbsp;int i=0, n, head, tail; <br />&nbsp;&nbsp; &nbsp;Node queue;&nbsp;&nbsp; &nbsp;// used as stack to do BFS <br />&nbsp;&nbsp; &nbsp;Node temp; <br /><br />&nbsp;&nbsp; &nbsp;while(graph[i]!=NULL){ <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].color = 0; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].index = i; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].parent = NULL; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].d = 0; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;i++; <br />&nbsp;&nbsp; &nbsp;} <br />&nbsp;&nbsp; &nbsp;n = i; <br />&nbsp;&nbsp; &nbsp;start-&gt;color = 1; <br />&nbsp;&nbsp; &nbsp;queue = (Node)malloc(n*sizeof(Node));&nbsp;&nbsp; &nbsp;// not sure here&#8230; <br />&nbsp;&nbsp; &nbsp;head = tail = 0; <br />&nbsp;&nbsp; &nbsp;enqueue(queue, &amp;tail, start); <br /><br />&nbsp;&nbsp; &nbsp;while(!isEmpty(head, tail)){ <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;temp = dequeue(queue, &amp;head); <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (i=0; i<n; i++){=""><br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(graphMatrix[temp-&gt;index][i]!=0){ <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(graph[i].color==0){ <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].color = 1; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].d = temp-&gt;d+1; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].parent = temp; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enqueue(queue, &amp;tail, graph[i]); <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;temp-&gt;color = 2; <br />&nbsp;&nbsp; &nbsp;} <br />} <br /><br />void initQueue(int *head, int *tail){ <br />&nbsp;&nbsp; &nbsp;*head = *tail =0; <br />} <br /><br />void enqueue(Node q, int *tail, Node element){ <br />&nbsp;&nbsp; &nbsp;q[(*tail)++]=element; <br />} <br /><br />Node dequeue(Node q, int *head){ <br />&nbsp;&nbsp; &nbsp;return q[(*head)++]; <br />} <br /><br />int isEmpty(int head, int tail){ <br />&nbsp;&nbsp; &nbsp;return head==tail? 1:0; <br />} <br /><br />int isFull(int tail, const int size){ <br />&nbsp;&nbsp; &nbsp;return tail==size? 1:0; <br />} <br /><br /><br />// Depth-First Search <br />// has more knowledge about the structure of the tree <br />// at the cost of a more complicated struct <br /><br />struct node{ <br />&nbsp;&nbsp; &nbsp;int index; <br />&nbsp;&nbsp; &nbsp;int color; <br />&nbsp;&nbsp; &nbsp;int detected; <br />&nbsp;&nbsp; &nbsp;int finished; <br />&nbsp;&nbsp; &nbsp;struct node *parent; <br />} <br />typedef struct node* Node; <br /><br />// the original algorithm in the textbook is a little bit wierd<br />// cause it is different from BFS by no need of starting point<br />// while it is obvious that starting with different points will <br />// generate trees with different structures, given the same link-matrix <br />void buildDFS(int *graphMatrx, Node graph, Node start){ <br />&nbsp;&nbsp; &nbsp;int i=0, n, time;<br />&nbsp;&nbsp; &nbsp;Node temp; <br />&nbsp;&nbsp; &nbsp;while(graph[i]!=NULL){ <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].color = 0; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].parent = NULL; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].detected = graph[i].finished = 0; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[i].index = i; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;i++; <br />&nbsp;&nbsp; &nbsp;}<br />&nbsp;&nbsp; &nbsp;n = i; <br />&nbsp;&nbsp; &nbsp;time = 0;<br />&nbsp;&nbsp; &nbsp;graph[1] = temp;<br />&nbsp;&nbsp; &nbsp;graph[1] = start;<br />&nbsp;&nbsp; &nbsp;start = temp;&nbsp;&nbsp; &nbsp;// just want to start at the beginning of the array <br />&nbsp;&nbsp; &nbsp;while(i&gt;=0){<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(graph[i].color == 0)<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;visitDFS(graphMatrix, graph, i, &amp;time, n);<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;i&#8211;;<br />&nbsp;&nbsp; &nbsp;}<br />}<br /><br />void visitDFS(int *graphMatrix, Node graph, int i, int *time, int length){<br />&nbsp;&nbsp; &nbsp;graph[i].color = 1;&nbsp;&nbsp; &nbsp;// grey, begin to visit<br />&nbsp;&nbsp; &nbsp;graph[i].detected = ++(*time);<br />&nbsp;&nbsp; &nbsp;for (int j=0; j<length; j++){=""><br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(graphMatrix[graph[i].index][j]!=0){<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if(graph[j].color == 0){<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;graph[j].parent = &amp;graph[i];<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;visitDFS(graphMatrix, graph, j, time, length);<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />&nbsp;&nbsp; &nbsp;}<br />&nbsp;&nbsp; &nbsp;graph[i].color = 2;&nbsp;&nbsp; &nbsp;// black, conclude the visiting<br />&nbsp;&nbsp; &nbsp;graph[i].finished = ++(*time);<br />}</length;></n;><br /><br /><n; i++){=""><length; j++){="">(<a href="http://creasywuqiong.blogspot.com/2011/03/tree-search-algorithm-cont.html">to be continued</a>) &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; </length;></n;><br />=========<br /><br />reference: &lt;<a href="http://www.amazon.com/Introduction-Algorithms-Third-Thomas-Cormen/dp/0262033844/ref=sr_1_2?ie=UTF8&amp;qid=1298923887&amp;sr=8-2">Introduction to algorithms</a>&gt;</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/02/21/some-abstract/">Some Abstract</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-02-21T00:00:00-05:00" pubdate data-updated="true">Feb 21<span>st</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
说到Unix为我们所带来的软件开发的哲学，我必需要说一说。Unix遵循的原则是KISS（Keep it simple, stupid）。在http://en.wikipedia.org/wiki/Unix_philosophy 上有很多的基本上大同小异的Unix哲学，都是很经典的。<br /><br />Doug McIlroy 是认为UNIX的哲学是这样的：三条哲学，简明扼要，就是这三条哲学贯穿着整个Unix世界。尤其是第一条“do one thing and do it well”真是相当精彩！<br /><br />&nbsp;&nbsp;&nbsp; * Write programs that do one thing and do it well.<br />&nbsp;&nbsp;&nbsp; * Write programs to work together.<br />&nbsp;&nbsp;&nbsp; * Write programs to handle text streams, because that is a universal interface.<br /><br />只要是Unix的程序员，他们会比别的程序员在任何时候都会不停地强调着这三条哲学。<br /><br />而《The Art of Unix Programming》总结了下面这些哲学，都是至理名言啊。<br /><br />&nbsp;&nbsp;&nbsp; * Rule of Modularity: Write simple parts connected by clean interfaces.<br />&nbsp;&nbsp;&nbsp; * Rule of Clarity: Clarity is better than cleverness.<br />&nbsp;&nbsp;&nbsp; * Rule of Composition: Design programs to be connected to other programs.<br />&nbsp;&nbsp;&nbsp; * Rule of Separation: Separate policy from mechanism; separate interfaces from engines.<br />&nbsp;&nbsp;&nbsp; * Rule of Simplicity: Design for simplicity; add complexity only where you must.<br />&nbsp;&nbsp;&nbsp; * Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do.<br />&nbsp;&nbsp;&nbsp; * Rule of Transparency: Design for visibility to make inspection and debugging easier.<br />&nbsp;&nbsp;&nbsp; * Rule of Robustness: Robustness is the child of transparency and simplicity.<br />&nbsp;&nbsp;&nbsp; * Rule of Representation: Fold knowledge into data so program logic can be stupid and robust.<br />&nbsp;&nbsp;&nbsp; * Rule of Least Surprise: In interface design, always do the least surprising thing.<br />&nbsp;&nbsp;&nbsp; * Rule of Silence: When a program has nothing surprising to say, it should say nothing.<br />&nbsp;&nbsp;&nbsp; * Rule of Repair: When you must fail, fail noisily and as soon as possible.<br />&nbsp;&nbsp;&nbsp; * Rule of Economy: Programmer time is expensive; conserve it in preference to machine time.<br />&nbsp;&nbsp;&nbsp; * Rule of Generation: Avoid hand-hacking; write programs to write programs when you can.<br />&nbsp;&nbsp;&nbsp; * Rule of Optimization: Prototype before polishing. Get it working before you optimize it.<br />&nbsp;&nbsp;&nbsp; * Rule of Diversity: Distrust all claims for “one true way”.<br />&nbsp;&nbsp;&nbsp; * Rule of Extensibility: Design for the future, because it will be here sooner than you think.<br /><br />X Windows 的设计者 Mike Gancarz 给出了下面九条哲学思想<br /><br />&nbsp;&nbsp; 1. Small is beautiful.<br />&nbsp;&nbsp; 2. Make each program do one thing well.<br />&nbsp;&nbsp; 3. Build a prototype as soon as possible.<br />&nbsp;&nbsp; 4. Choose portability over efficiency.<br />&nbsp;&nbsp; 5. Store data in flat text files.<br />&nbsp;&nbsp; 6. Use software leverage to your advantage.<br />&nbsp;&nbsp; 7. Use shell scripts to increase leverage and portability.<br />&nbsp;&nbsp; 8. Avoid captive user interfaces.<br />&nbsp;&nbsp; 9. Make every program a filter.<br /><br /><br />十条不错的编程观点<br />1） The only “best practice” you should be using all the time is “Use Your Brain”, rather than some so-called &#8220;famous&#8221; frameworks, methods, classes, or prototypes.<br />2）Programmers who don’t code in their spare time for fun will never become as good as those that do.<br />3）Most comments in code are in fact a pernicious form of code duplication, which should explain &#8220;why&#8221;, rather than &#8220;how&#8221; and &#8220;what&#8221;.<br />4）XML is highly overrated<br />5）Not all programmers are created equal<br />6）”Googling it” is okay!<br />7）If you only know one language, no matter how well you know it, you’re not a great programmer.<br />8）Your job is to put yourself out of work. Or, saying, if you can’t be replaced then you can’t be promoted!<br />9）Design patterns are hurting good design more than they’re helping it.<br />10）Unit Testing won’t help you write good code</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/12/18/vim-setup/">Vim Setup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-12-18T00:00:00-05:00" pubdate data-updated="true">Dec 18<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
The configuration should be done in the file named &#8220;vimrc&#8221;.<br /><br />For linux os, the directory should be: /etc/vim/vimrc.&nbsp;For Unix, without root privilege, just as I am&#8230;, it needs to make a new file named &#8220;.vimrc&#8221; in the $HOME/ directory. As the vim starting, it will automatically read this file for configuration. And, the punctuation quotes &#8221; is the sign for comment.<br /><br />&#8221; syntax highlighting<br />syntax on<br />&#8221; automatic&nbsp;indentation<br />set autoindent<br />&#8221; specifically c/c++ indentation<br />set cindent<br />&#8221; to show the line number for each line<br />set nu<br /><br />Have fun:)</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/12/18/cc-open-file/">C/c++ Input/ouput Functions</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-12-18T00:00:00-05:00" pubdate data-updated="true">Dec 18<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
<b>int open(char * filename, int flags)<br />int open(char * filename, int flags, int mode)</b><br />include: fcntl.h<br />flags = bitwise | or of any of the following:<br />&nbsp;&nbsp;&nbsp;&nbsp; O_RDONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Only read operations permitted<br />&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Only write operations permitted<br />&nbsp;&nbsp;&nbsp;&nbsp; O_RDWR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Read and Write operations both permitted<br />&nbsp;&nbsp;&nbsp;&nbsp; O_NONBLOCK&nbsp;&nbsp;&nbsp; Non-blocking, applies to open operation only<br />&nbsp;&nbsp;&nbsp;&nbsp; O_APPEND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All writes go to end of file<br />&nbsp;&nbsp;&nbsp;&nbsp; O_CREAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create file if it doesn&#8217;t already exist<br />&nbsp;&nbsp;&nbsp;&nbsp; O_TRUNC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Delete existing contents of file<br />&nbsp;&nbsp;&nbsp;&nbsp; O_EXCL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open fails if file already exists<br />&nbsp;&nbsp;&nbsp;&nbsp; O_SHLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get a &#8220;shared lock&#8221; on the file<br />&nbsp;&nbsp;&nbsp;&nbsp; O_EXLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get an &#8220;exclusive lock&#8221; on the file<br />&nbsp;&nbsp;&nbsp;&nbsp; O_DIRECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Try to avoid all caching of operations<br />&nbsp;&nbsp;&nbsp;&nbsp; O_FSYNC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All writes immediately effective, no buffering<br />&nbsp;&nbsp;&nbsp;&nbsp; O_NOFOLLOW&nbsp;&nbsp;&nbsp; If file is symbolic link, open it, don&#8217;t follow it<br />mode required if file is created, ignored otherwise.<br />mode specifies the protection bits, e.g. 0644 = rw-r&#8211;r&#8211;<br />returns &lt;0 for error, or integer file descriptor.<br /><br /><b>int close(int fd)</b><br />include: unistd.h<br />fd = file descriptor as returned by open<br />returns &lt;0 for error, 0 for success.<br /><br /><b>int read(int fd, void * ptr, int numbytes)</b><br />include: unistd.h<br />fd = file descriptor as returned by open<br />ptr = address in memory where data is to be stored;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; may be a pointer of any type.<br />numbytes = number of bytes to attempt to read<br />returns &lt;0 for error, 0 for end-of-file,or number of bytes successfully read. (for a non-blocking interactive file, that may be zero).<br /><br /><b>int write(int fd, void * ptr, int numbytes)</b><br />include: unistd.h<br />fd = file descriptor as returned by open<br />ptr = address in memory where data already is;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; may be a pointer of any type.<br />numbytes = number of bytes to attempt to write<br />returns &lt;=0 for error, or number of bytes successfully written. (for a non-blocking file, that may be less than the number attempted without any errors having occurred).<br /><br /><b>int lseek(int fd, int position, int startpoint)</b><br />include: unistd.h<br />Sets the file position effective for the next read or write operation.<br />fd = file descriptor as returned by open<br />position = position within file: number of bytes between startpoint and the desired position, may be negative.<br />startpoint = location in file that position is relative to, one of:<br />&nbsp;&nbsp;&nbsp;&nbsp; SEEK_SET: Position is number of bytes from beginning of file<br />&nbsp;&nbsp;&nbsp;&nbsp; SEEK_END: Position is number of bytes after end of file<br />&nbsp;&nbsp;&nbsp;&nbsp; SEEK_CUR: Position is number of bytes after current position<br />returns &lt;0 for error, or resulting file position relative to beginning of file. Moving beyond the end of the file is permitted; the file is extended in length only if a write occurs beyond the current end of file. Moveing before the beginning of a file is not permitted. A write operation after a move only overwrites the number of bytes actually written.<br /><br /><b>int stat(char * file, struct stat * info)</b><br />include: sys/types.h<br />include: sys/stat.h<br />Finds information about a file.<br />file = The name (or path) for the file.<br />info = A pointer to an uninitialised stat structure. Even in C++, the type must be &#8220;struct stat *&#8221; because of the name clash. Information about the file is stored in the info object.<br />returns &lt;0 for error (including file does not exist), or 0&nbsp; for success.<br />The useful fields of a stat object are as follows. All have types that behave like ints, although they may be 16, 32, or 64 bits long.<br />&nbsp;&nbsp;&nbsp;&nbsp; st_size: size in bytes<br />&nbsp;&nbsp;&nbsp;&nbsp; st_ino: inode number<br />&nbsp;&nbsp;&nbsp;&nbsp; st_mode: protection or mode (see below)<br />&nbsp;&nbsp;&nbsp;&nbsp; st_nlink: number of hard links<br />&nbsp;&nbsp;&nbsp;&nbsp; st_uid: file&#8217;s owner&#8217;s identification number<br />&nbsp;&nbsp;&nbsp;&nbsp; st_gid: file&#8217;s group identification number<br />&nbsp;&nbsp;&nbsp;&nbsp; st_birthtime: date and time of file creation (see below)<br />&nbsp;&nbsp;&nbsp;&nbsp; st_mtime: date and time of last modification (see below)<br />&nbsp;&nbsp;&nbsp;&nbsp; st_atime: date and time of last access (see below)<br />All times are stored as time_t values, as described here. Mode and Protection. st_mode is the logical-or of a number of bits each representing different properties. The named constants for these bits, and their values in octal are:<br />&nbsp;&nbsp;&nbsp;&nbsp; S_ISUID&nbsp; 0004000&nbsp; set user id on execution<br />&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR&nbsp; 0000400&nbsp; protection: readable by owner<br />&nbsp;&nbsp;&nbsp;&nbsp; S_IWUSR&nbsp; 0000200&nbsp; writable by owner<br />&nbsp;&nbsp;&nbsp;&nbsp; S_IXUSR&nbsp; 0000100&nbsp; executable by owner<br />&nbsp;&nbsp;&nbsp;&nbsp; S_IRGRP&nbsp; 0000040&nbsp; readable by group<br />&nbsp;&nbsp;&nbsp;&nbsp; S_IWGRP&nbsp; 0000020&nbsp; writable by group<br />&nbsp;&nbsp;&nbsp;&nbsp; S_IXGRP&nbsp; 0000010&nbsp; executable by group<br />&nbsp;&nbsp;&nbsp;&nbsp; S_IROTH&nbsp; 0000004&nbsp; readable by all<br />&nbsp;&nbsp;&nbsp;&nbsp; S_IWOTH&nbsp; 0000002&nbsp; writable by all<br />&nbsp;&nbsp;&nbsp;&nbsp; S_IXOTH&nbsp; 0000001&nbsp; executable by all<br />Four bits of the mode give the file type. The mask for type is S_IFMT = 0170000<br />if (mode &amp; S_IFMT) is S_IFREG = 0100000,&nbsp; type = perfectly ordinary file<br />if (mode &amp; S_IFMT) is S_IFDIR = 0040000,&nbsp; type = directory<br />if (mode &amp; S_IFMT) is S_IFLNK = 0120000,&nbsp; type = symbolic link<br />if (mode &amp; S_IFMT) is S_IFIFO = 0010000,&nbsp; type = named pipe<br />if (mode &amp; S_IFMT) is S_IFSOCK = 0140000,&nbsp; type = named socket<br /><br /><b>File Mode or Protection Bits</b><br /><br />A file&#8217;s mode or protection is usually specified visually by 9 characters, for example rw-r&#8211;r&#8211; or rwxr-x&#8211;x. Each of the letters are (nearly always) &#8216;r&#8217; for read permitted, &#8216;w&#8217; for write permitted, or &#8216;x&#8217; for execute permitted.<br /><br />The letters always appear in groups of three. Within a group, the order is always &#8216;rwx&#8217;. The first group of three indicate operations permitted to the owner of the file; the second group of three indicates operations permitted to other users in the same group as the owner; the third group of three indicates operations permitted to all users who can access the file.<br /><br />If the file is a directory, &#8216;x&#8217; means that files in the directory may be accessed if referred to directly by name, but wildcard substitutions (&#8216;*&#8217;) and ls operations will not be permitted.<br /><br />Modes are usually represented inside programs by a sequence of three octal digits. each octal digit represents one of the groups of three characters, 4 for &#8216;r&#8217; plus 2 for &#8216;w&#8217; plus 1 for &#8216;x&#8217;. In C and C++ programs remember that numbers with leading zeros are always assumed to be in octal, so the mode 0751 represents rwxr-x&#8211;x.</div>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/8/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/6/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/04/12/thought-process-in-a-tennis-match/">Thought Process in a Tennis Match</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/05/survive-on-busy-two-weeks/">Survive on Busy Two weeks</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/01/strategic-playing-for-the-first-several-sets/">Strategic Playing for the First Several Sets</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/27/plotting-in-latex/">Plotting in Latex</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/24/better-look-for-git-log/">Better look for &#8220;git log&#8221;</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  <a href="https://github.com/creasyw">Qiong Wu</a> &copy;2009-2014 &mdash;
  <span class="credit">Thanks to <a href="http://ayyang.com">Alex Yang</a>, <a href="http://octopress.org/">Octopress</a> and <a href="https://github.com/">Github</a>.</span><br>
  send me an email 
<script type="text/javascript">
var emailriddlerarray=[99,114,101,97,115,121,119,117,113,105,111,110,103,64,103,109,97,105,108,46,99,111,109]
var encryptedemail_id82='' //variable to contain encrypted email 
for (var i=0; i<emailriddlerarray.length; i++)
 encryptedemail_id82+=String.fromCharCode(emailriddlerarray[i])
 document.write('<a href="mailto:'+encryptedemail_id82+'"><img src="/img/email.png" alt="Qiong" /></a>')
</script>
</p>
</footer>
</body>
</html>
