
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>advance info. about usrp trans. - Qiong Wu</title>
  <meta name="author" content="Qiong Wu">

  
  <meta name="description" content="new examples for the 802.11b trans. (here)======================btw, there is an excellent discussion about how to run the code.(1)&nbsp;HiI am &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://creasyw.github.io/blog/2010/10/18/advance-info-about-usrp-trans/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <!-- add Mathjex.js by qiong -->
  <script src="http://kramdown.rubyforge.org/MathJax/MathJax.js" type="text/javascript"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="./atom.xml" rel="alternate" title="Qiong Wu" type="application/atom+xml">
  
  <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  
  
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Qiong Wu</a></h1>
  <!--
  
    <h2>A blogging framework for hackers.</h2>
  
  -->
</hgroup>
</header>
  <nav role="navigation"><!--
<ul class="subscription" data-subscription="rss">
  <li><a href="./atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:creasyw.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

-->

<ul class="main-navigation">
  <!--<li><a class="yellow" href="/">Hello</a></li>-->
  <li><a class="github" href="/blog/archives/">Blog</a></li>
  <li><a class="github" href="/tags">Tags</a></li>
  <li><a class="github" href="http://www.github.com/creasyw">Github</a></li>
  <li><a class="github" href="https://twitter.com/creasywuqiong">Twitter</a></li>
  <li><a class="github" href="/rss">RSS</a></li>
</ul>


</nav>
  <div id="main">
    <div id="content">
      <article>
  <header>
    
      <h1 class="entry-title">Advance Info. About Usrp Trans.</h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-18T00:00:00-07:00" pubdate data-updated="true">Oct 18<span>th</span>, 2010</time>
        
      </p>
    
  </header>


<div class="entry-content"><div class='post'>
new examples for the 802.11b trans. (<a href="https://www.cgran.org/browser/projects/bbn_80211/branches/douggeiger/src/examples?rev=113">here</a>)<br /><br />======================<br /><br />btw, there is an <a href="http://www.mail-archive.com/discuss-gnuradio@gnu.org/msg18734.html">excellent discussion</a> about how to run the code.<br /><br /><b><span style="font-size: large;">(1)</span></b><br /><pre>&nbsp;</pre><pre>Hi</pre><br />I am trying to establish communication between USRP2 and USRP1. I am using RFX2400 daughterboard. I am using Ubuntu 8.10. I am using the svn version of GNU Radio. I dont know the revision number. I am not able to receive anything on USRP2 when USRP1 is transmitting and vice versa. The python codes for USRP2 work perfectly fine. I guess there is some problem with the ADC and DAC incompatibility (interpolation and decimation) between USRP2 and USRP1. I am attaching all the necessary files that I am using currently. I would appreciate if someone can look at these files and help me to sort out the problem. &nbsp; </pre><br /><br /><pre>benchmark_tx.py
<br />
<br />#!/usr/bin/env python
<br />#
<br /># Copyright 2005, 2006, 2007 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />from gnuradio import gr, gru, modulation_utils
<br />from gnuradio import usrp2
<br />from gnuradio import eng_notation
<br />from gnuradio.eng_option import eng_option
<br />from optparse import OptionParser
<br />
<br />import random
<br />import time
<br />import struct
<br />import sys
<br />
<br /># from current dir
<br />from transmit_path_usrp2 import transmit_path
<br />import fusb_options
<br />
<br />#import os 
<br />#print os.getpid()
<br />#raw_input('Attach and press enter')
<br />
<br />class my_top_block(gr.top_block):
<br />    def __init__(self, modulator, options):
<br />        gr.top_block.__init__(self)
<br />        self.txpath = transmit_path(modulator, options)
<br />        self.connect(self.txpath)
<br />
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />#                                   main
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />
<br />def main():
<br />
<br />    def send_pkt(payload='', eof=False):
<br />        return tb.txpath.send_pkt(payload, eof)
<br />
<br />    def rx_callback(ok, payload):
<br />        print "ok = %r, payload = '%s'" % (ok, payload)
<br />
<br />    mods = modulation_utils.type_1_mods()
<br />
<br />    parser = OptionParser(option_class=eng_option,
<br />conflict_handler="resolve")
<br />    expert_grp = parser.add_option_group("Expert")
<br />
<br />    parser.add_option("-m", "--modulation", type="choice",
<br />choices=mods.keys(),
<br />                      default='gmsk',
<br />                      help="Select modulation from: %s [default=%%default]"
<br />                            % (', '.join(mods.keys()),))
<br />
<br />    parser.add_option("-s", "--size", type="eng_float", default=1500,
<br />                      help="set packet size [default=%default]")
<br />    parser.add_option("-M", "--megabytes", type="eng_float", default=1.0,
<br />                      help="set megabytes to transmit [default=%default]")
<br />    parser.add_option("","--discontinuous", action="store_true",
<br />default=False,
<br />                      help="enable discontinous transmission (bursts of 5
<br />packets)")
<br />    parser.add_option("","--from-file", default=None,
<br />                      help="use file for packet contents")
<br />
<br />    transmit_path.add_options(parser, expert_grp)
<br />
<br />    for mod in mods.values():
<br />        mod.add_options(expert_grp)
<br />
<br />    fusb_options.add_options(expert_grp)
<br />    (options, args) = parser.parse_args ()
<br />
<br />    if len(args) != 0:
<br />        parser.print_help()
<br />        sys.exit(1)
<br />
<br />    if options.tx_freq is None:
<br />        sys.stderr.write("You must specify -f FREQ or --freq FREQ\n")
<br />        parser.print_help(sys.stderr)
<br />        sys.exit(1)
<br />
<br />    if options.from_file is not None:
<br />        source_file = open(options.from_file, 'r')
<br />
<br />    # build the graph
<br />    tb = my_top_block(mods[options.modulation], options)
<br />
<br />    r = gr.enable_realtime_scheduling()
<br />    if r != gr.RT_OK:
<br />        print "Warning: failed to enable realtime scheduling"
<br />
<br />    tb.start()                       # start flow graph
<br />        
<br />    # generate and send packets
<br />    nbytes = int(1e6 * options.megabytes)
<br />    n = 0
<br />    pktno = 0
<br />    pkt_size = int(options.size)
<br />
<br />    while n &lt; nbytes:
<br />        if options.from_file is None:
<br />            data = (pkt_size - 2) * chr(pktno &amp; 0xff) 
<br />        else:
<br />            data = source_file.read(pkt_size - 2)
<br />            if data == '':
<br />                break;
<br />
<br />        payload = struct.pack('!H', pktno &amp; 0xffff) + data
<br />        send_pkt(payload)
<br />        n += len(payload)
<br />        sys.stderr.write('.')
<br />        if options.discontinuous and pktno % 5 == 4:
<br />            time.sleep(1)
<br />        pktno += 1
<br />        
<br />    send_pkt(eof=True)
<br />
<br />    tb.wait()                       # wait for it to finish
<br />
<br />if __name__ == '__main__':
<br />    try:
<br />        main()
<br />    except KeyboardInterrupt:
<br />        pass
<br />
<br />
<br />transmit_path_usrp2.py
<br />
<br />#
<br /># Copyright 2005,2006,2007 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />from gnuradio import gr, gru, blks2
<br />from gnuradio import usrp2
<br />from gnuradio import eng_notation
<br />
<br />import copy
<br />import sys
<br />
<br /># from current dir
<br />from pick_bitrate import pick_tx_bitrate
<br />
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />#                              transmit path
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />
<br />class transmit_path(gr.hier_block2): 
<br />    def __init__(self, modulator_class, options):
<br />        '''
<br />        See below for what options should hold
<br />        '''
<br />        gr.hier_block2.__init__(self, "transmit_path",
<br />                                gr.io_signature(0, 0, 0), # Input signature
<br />                                gr.io_signature(0, 0, 0)) # Output signature
<br />
<br />        options = copy.copy(options)    # make a copy so we can
<br />destructively modify
<br />
<br />        self._interface          = options.interface           # the USRP
<br />board attached
<br />        self._mac_addr           = options.mac_addr
<br />        self._verbose            = options.verbose
<br />        self._tx_freq            = options.tx_freq         # tranmitter's
<br />center frequency
<br />        self._tx_amplitude       = options.tx_amplitude    # digital
<br />amplitude sent to USRP
<br />        #self._tx_subdev_spec     = options.tx_subdev_spec  # daughterboard
<br />to use
<br />        self._bitrate            = options.bitrate         # desired bit
<br />rate
<br />        self._interp             = options.interp          # interpolating rate 
<br />for
<br />the USRP (prelim) 
<br />        self._samples_per_symbol = options.samples_per_symbol  # desired
<br />samples/baud 
<br />        #self._fusb_block_size    = options.fusb_block_size # usb info for USRP
<br />        #self._fusb_nblocks       = options.fusb_nblocks    # usb info for
<br />USRP
<br />        self._use_whitener_offset = options.use_whitener_offset # increment
<br />start of whitener XOR data
<br />        
<br />        self._modulator_class = modulator_class         # the
<br />modulator_class we are using
<br />    
<br />        if self._tx_freq is None:
<br />            sys.stderr.write("-f FREQ or --freq FREQ or --tx-freq FREQ must
<br />be specified\n")
<br />            raise SystemExit
<br />
<br />        # Set up USRP sink; also adjusts interp, samples_per_symbol, and
<br />bitrate
<br />        self._setup_usrp_sink()  
<br />
<br />        # copy the final answers back into options for use by modulator
<br />        options.samples_per_symbol = self._samples_per_symbol
<br />        options.bitrate = self._bitrate
<br />        options.interp = self._interp
<br />
<br />        # Get mod_kwargs
<br />        mod_kwargs =
<br />self._modulator_class.extract_kwargs_from_options(options)
<br />
<br />        # Set center frequency of USRP
<br />        ok = self.set_freq(self._tx_freq)
<br />        if not ok:
<br />            print "Failed to set Tx frequency to %s" %
<br />(eng_notation.num_to_str(self._tx_freq),)
<br />            raise ValueError
<br />    
<br />        # transmitter
<br />        self.packet_transmitter = \
<br />            blks2.mod_pkts(self._modulator_class(**mod_kwargs),
<br />                           access_code=None,
<br />                           msgq_limit=4,
<br />                           pad_for_usrp=True,
<br />                           use_whitener_offset=options.use_whitener_offset)
<br />
<br />
<br />        # Set the USRP for maximum transmit gain
<br />        # (Note that on the RFX cards this is a nop.)
<br />        self.set_gain(self.u.gain_range()[1])
<br />
<br />        self.amp = gr.multiply_const_cc(1)
<br />        self.set_tx_amplitude(self._tx_amplitude)
<br />
<br />        # enable Auto Transmit/Receive switching
<br />        #fiske_removed self.set_auto_tr(True)
<br />
<br />        # Display some information about the setup
<br />        if self._verbose:
<br />            self._print_verbage()
<br />
<br />        # Create and setup transmit path flow graph
<br />        self.connect(self.packet_transmitter, self.amp, self.u)
<br />
<br />    def _setup_usrp_sink(self):
<br />        """
<br />        Creates a USRP sink, determines the settings for best bitrate,
<br />        and attaches to the transmitter's subdevice.
<br />        """
<br />        #self.u = usrp2.source_32fc(options.interface, options.mac_addr)
<br />        #self.u = usrp2.sink_32fc (options._interface, options._mac_addr)
<br />        self.u = usrp2.sink_32fc("eth0","00:50:C2:85:31:5A")  #fiske hard coded 
<br />        dac_rate = self.u.dac_rate();
<br />
<br />        # derive values of bitrate, samples_per_symbol, and interp from
<br />desired info
<br />        (self._bitrate, self._samples_per_symbol, self._interp) = \
<br />            pick_tx_bitrate(self._bitrate,
<br />self._modulator_class.bits_per_symbol(),
<br />                            self._samples_per_symbol, self._interp,
<br />dac_rate)
<br />        
<br />        #fiske_removed self.u.set_interp_rate(self._interp)
<br />
<br />        # determine the daughterboard subdevice we're using
<br />        #if self._tx_subdev_spec is None:
<br />        #    self._tx_subdev_spec = usrp.pick_tx_subdevice(self.u)
<br />        #self.u.set_mux(usrp.determine_tx_mux_value(self.u,
<br />self._tx_subdev_spec))
<br />        #self.subdev = usrp.selected_subdev(self.u, self._tx_subdev_spec)
<br />
<br />
<br />    def set_freq(self, target_freq):
<br />        """
<br />        Set the center frequency we're interested in.
<br />
<br />        @param target_freq: frequency in Hz
<br />        @rypte: bool
<br />
<br />        Tuning is a two step process.  First we ask the front-end to
<br />        tune as close to the desired frequency as it can.  Then we use
<br />        the result of that operation and our target_frequency to
<br />        determine the value for the digital up converter.
<br />        """
<br />        r = self.u.set_center_freq(target_freq)
<br />        if r:
<br />            return True
<br />
<br />        return False
<br />        
<br />    def set_gain(self, gain):
<br />        """
<br />        Sets the analog gain in the USRP
<br />        """
<br />        self.gain = gain
<br />        self.u.set_gain(gain)
<br />
<br />    def set_tx_amplitude(self, ampl):
<br />        """
<br />        Sets the transmit amplitude sent to the USRP
<br />        @param: ampl 0 &lt;= ampl &lt; 32768.  Try 8000
<br />        """
<br />        self._tx_amplitude = max(0.0, min(ampl, 32767.0))
<br />        self.amp.set_k(self._tx_amplitude)
<br />        
<br />    def set_auto_tr(self, enable):
<br />        """
<br />        Turns on auto transmit/receive of USRP daughterboard (if exits; else
<br />ignored)
<br />        """
<br />        return self.u.set_auto_tr(enable)
<br />        
<br />    def send_pkt(self, payload='', eof=False):
<br />        """
<br />        Calls the transmitter method to send a packet
<br />        """
<br />        return self.packet_transmitter.send_pkt(payload, eof)
<br />        
<br />    def bitrate(self):
<br />        return self._bitrate
<br />
<br />    def samples_per_symbol(self):
<br />        return self._samples_per_symbol
<br />
<br />    def interp(self):
<br />        return self._interp
<br />
<br />    def add_options(normal, expert):
<br />        """
<br />        Adds transmitter-specific options to the Options Parser
<br />        """
<br />        add_freq_option(normal)
<br />        if not normal.has_option('--bitrate'):
<br />            normal.add_option("-r", "--bitrate", type="eng_float",
<br />default=None,
<br />                              help="specify bitrate.  samples-per-symbol and
<br />interp/decim will be derived.")
<br />        normal.add_option("-e", "--interface", type="string",
<br />default="eth0",
<br />                          help="select Ethernet interface, default is eth0")
<br />        normal.add_option("-m", "--mac-addr", type="string", default="",
<br />                          help="select USRP by MAC address, default is
<br />auto-select")
<br />        #normal.add_option("-T", "--tx-subdev-spec", type="subdev",
<br />default=None,
<br />        #                  help="select USRP Tx side A or B")
<br />        normal.add_option("", "--tx-amplitude", type="eng_float",
<br />default=12000, metavar="AMPL",
<br />                          help="set transmitter digital amplitude: 0 &lt;= AMPL
<br />&lt; 32768 [default=%default]")
<br />        normal.add_option("-v", "--verbose", action="store_true",
<br />default=False)
<br />
<br />        expert.add_option("-S", "--samples-per-symbol", type="int",
<br />default=None,
<br />                          help="set samples/symbol [default=%default]")
<br />        expert.add_option("", "--tx-freq", type="eng_float", default=None,
<br />                          help="set transmit frequency to FREQ
<br />[default=%default]", metavar="FREQ")
<br />        expert.add_option("-i", "--interp", type="intx", default=None,
<br />                          help="set fpga interpolation rate to INTERP
<br />[default=%default]")
<br />        expert.add_option("", "--log", action="store_true", default=False,
<br />                          help="Log all parts of flow graph to file
<br />(CAUTION: lots of data)")
<br />        expert.add_option("","--use-whitener-offset", action="store_true",
<br />default=False,
<br />                          help="make sequential packets use different
<br />whitening")
<br />
<br />    # Make a static method to call before instantiation
<br />    add_options = staticmethod(add_options)
<br />
<br />    def _print_verbage(self):
<br />        """
<br />        Prints information about the transmit path
<br />        """
<br />        print "Using TX d'board %s"    % (self.u.daughterboard_id(),)
<br />        print "Tx amplitude     %s"    % (self._tx_amplitude)
<br />        print "modulation:      %s"    % (self._modulator_class.__name__)
<br />        print "bitrate:         %sb/s" %
<br />(eng_notation.num_to_str(self._bitrate))
<br />        print "samples/symbol:  %3d"   % (self._samples_per_symbol)
<br />        print "interp:          %3d"   % (self._interp)
<br />        print "Tx Frequency:    %s"    %
<br />(eng_notation.num_to_str(self._tx_freq))
<br />        
<br />
<br />def add_freq_option(parser):
<br />    """
<br />    Hackery that has the -f / --freq option set both tx_freq and rx_freq
<br />    """
<br />    def freq_callback(option, opt_str, value, parser):
<br />        parser.values.rx_freq = value
<br />        parser.values.tx_freq = value
<br />
<br />    if not parser.has_option('--freq'):
<br />        parser.add_option('-f', '--freq', type="eng_float",
<br />                          action="callback", callback=freq_callback,
<br />                          help="set Tx and/or Rx frequency to FREQ
<br />[default=%default]",
<br />                          metavar="FREQ")
<br />
<br />benchmark_rx.py
<br />
<br />#!/usr/bin/env python
<br />#
<br /># Copyright 2005,2006,2007 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />from gnuradio import gr, gru, modulation_utils
<br />from gnuradio import usrp2
<br />from gnuradio import eng_notation
<br />from gnuradio.eng_option import eng_option
<br />from optparse import OptionParser
<br />
<br />import random
<br />import struct
<br />import sys
<br />
<br /># from current dir
<br />from receive_path_usrp2 import receive_path
<br />import fusb_options
<br />
<br />#import os
<br />#print os.getpid()
<br />#raw_input('Attach and press enter: ')
<br />
<br />class my_top_block(gr.top_block):
<br />    def __init__(self, demodulator, rx_callback, options):
<br />        gr.top_block.__init__(self)
<br />        self.rxpath = receive_path(demodulator, rx_callback, options) 
<br />        self.connect(self.rxpath)
<br />
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />#                                   main
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />
<br />global n_rcvd, n_right
<br />
<br />def main():
<br />    global n_rcvd, n_right
<br />
<br />    n_rcvd = 0
<br />    n_right = 0
<br />    
<br />    def rx_callback(ok, payload):
<br />        global n_rcvd, n_right
<br />        (pktno,) = struct.unpack('!H', payload[0:2])
<br />        n_rcvd += 1
<br />        if ok:
<br />            n_right += 1
<br />
<br />        print "ok = %5s  pktno = %4d  n_rcvd = %4d  n_right = %4d" % (
<br />            ok, pktno, n_rcvd, n_right)
<br />
<br />
<br />    demods = modulation_utils.type_1_demods()
<br />
<br />    # Create Options Parser:
<br />    parser = OptionParser (option_class=eng_option,
<br />conflict_handler="resolve")
<br />    expert_grp = parser.add_option_group("Expert")
<br />
<br />    parser.add_option("-m", "--modulation", type="choice",
<br />choices=demods.keys(), 
<br />                      default='gmsk',
<br />                      help="Select modulation from: %s [default=%%default]"
<br />                            % (', '.join(demods.keys()),))
<br />
<br />    receive_path.add_options(parser, expert_grp)
<br />
<br />    for mod in demods.values():
<br />        mod.add_options(expert_grp)
<br />
<br />    fusb_options.add_options(expert_grp)
<br />    (options, args) = parser.parse_args ()
<br />
<br />    if len(args) != 0:
<br />        parser.print_help(sys.stderr)
<br />        sys.exit(1)
<br />
<br />    if options.rx_freq is None:
<br />        sys.stderr.write("You must specify -f FREQ or --freq FREQ\n")
<br />        parser.print_help(sys.stderr)
<br />        sys.exit(1)
<br />
<br />
<br />    # build the graph
<br />    tb = my_top_block(demods[options.modulation], rx_callback, options)
<br />
<br />    r = gr.enable_realtime_scheduling()
<br />    if r != gr.RT_OK:
<br />        print "Warning: Failed to enable realtime scheduling."
<br />
<br />    tb.start()        # start flow graph
<br />    tb.wait()         # wait for it to finish
<br />
<br />if __name__ == '__main__':
<br />    try:
<br />        main()
<br />    except KeyboardInterrupt:
<br />        pass
<br />
<br />receive_path_usrp2.py
<br />
<br />#!/usr/bin/env python
<br />#
<br /># Copyright 2005,2006,2007 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />from gnuradio import gr, gru, blks2
<br />from gnuradio import usrp2
<br />from gnuradio import eng_notation
<br />import copy
<br />import sys
<br />
<br /># from current dir
<br />from pick_bitrate import pick_rx_bitrate
<br />
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />#                              receive path
<br />#
<br />/////////////////////////////////////////////////////////////////////////////
<br />
<br />class receive_path(gr.hier_block2):
<br />    def __init__(self, demod_class, rx_callback, options):
<br />
<br />        gr.hier_block2.__init__(self, "receive_path",
<br />                                gr.io_signature(0, 0, 0), # Input signature
<br />                                gr.io_signature(0, 0, 0)) # Output signature
<br />
<br />        options = copy.copy(options)    # make a copy so we can
<br />destructively modify
<br />
<br />        self._interface          = options.interface           # the USRP
<br />board attached
<br />        self._mac_addr           = options.mac_addr
<br />        self._verbose            = options.verbose
<br />        self._rx_freq            = options.rx_freq         # receiver's
<br />center frequency
<br />        self._rx_gain            = options.rx_gain         # receiver's gain
<br />        #self._rx_subdev_spec     = options.rx_subdev_spec  # daughterboard
<br />to use
<br />        self._bitrate            = options.bitrate         # desired bit
<br />rate 
<br />        self._decim              = options.decim           # Decimating rate
<br />for the USRP (prelim) 
<br />        self._samples_per_symbol = options.samples_per_symbol  # desired
<br />samples/symbol
<br />        self._fusb_block_size    = options.fusb_block_size # usb info for USRP
<br />        self._fusb_nblocks       = options.fusb_nblocks    # usb info for
<br />USRP
<br />
<br />        self._rx_callback   = rx_callback      # this callback is fired when
<br />there's a packet available
<br />        self._demod_class   = demod_class      # the demodulator_class we're
<br />using
<br />
<br />        if self._rx_freq is None:
<br />            sys.stderr.write("-f FREQ or --freq FREQ or --rx-freq FREQ must
<br />be specified\n")
<br />            raise SystemExit
<br />
<br />        # Set up USRP source; also adjusts decim, samples_per_symbol, and
<br />bitrate
<br />        self._setup_usrp_source()
<br />
<br />        g = self.u.gain_range()
<br />        if options.show_rx_gain_range:
<br />            print "Rx Gain Range: minimum = %g, maximum = %g, step size =
<br />%g" \
<br />                  % (g[0], g[1], g[2])
<br />
<br />        self.set_gain(options.rx_gain)
<br />
<br />        self.set_auto_tr(True)                 # enable Auto
<br />Transmit/Receive switching
<br />
<br />        # Set RF frequency
<br />        ok = self.set_freq(self._rx_freq)
<br />        if not ok:
<br />            print "Failed to set Rx frequency to %s" %
<br />(eng_notation.num_to_str(self._rx_freq))
<br />            raise ValueError, eng_notation.num_to_str(self._rx_freq)
<br />
<br />        # copy the final answers back into options for use by demodulator
<br />        options.samples_per_symbol = self._samples_per_symbol
<br />        options.bitrate = self._bitrate
<br />        options.decim = self._decim
<br />
<br />        # Get demod_kwargs
<br />        demod_kwargs =
<br />self._demod_class.extract_kwargs_from_options(options)
<br />        # Fix USRP2 -&gt; USRP1 scaling
<br />        self.scale = gr.multiply_const_cc(32768)
<br />        # Design filter to get actual channel we want
<br />        sw_decim = 1
<br />        chan_coeffs = gr.firdes.low_pass (1.0,                  # gain
<br />                                          sw_decim *
<br />self._samples_per_symbol, # sampling rate
<br />                                          1.0,                  # midpoint
<br />of trans. band
<br />                                          0.5,                  # width of
<br />trans. band
<br />                                          gr.firdes.WIN_HANN)   # filter
<br />type 
<br />
<br />        # Decimating channel filter
<br />        # complex in and out, float taps
<br />        self.chan_filt = gr.fft_filter_ccc(sw_decim, chan_coeffs)
<br />        #self.chan_filt = gr.fir_filter_ccf(sw_decim, chan_coeffs)
<br />
<br />        # receiver
<br />        self.packet_receiver = \
<br />            blks2.demod_pkts(self._demod_class(**demod_kwargs),
<br />                             access_code=None,
<br />                             callback=self._rx_callback,
<br />                             threshold=-1)
<br />    
<br />        # Carrier Sensing Blocks
<br />        alpha = 0.001
<br />        thresh = 30   # in dB, will have to adjust
<br />
<br />        if options.log_rx_power == True:
<br />            self.probe = gr.probe_avg_mag_sqrd_cf(thresh,alpha)
<br />            self.power_sink = gr.file_sink(gr.sizeof_float, "rxpower.dat")
<br />            self.connect(self.chan_filt, self.probe, self.power_sink)
<br />        else:
<br />            self.probe = gr.probe_avg_mag_sqrd_c(thresh,alpha)
<br />            self.connect(self.chan_filt, self.probe)
<br />
<br />        # Display some information about the setup
<br />        if self._verbose:
<br />            self._print_verbage()
<br />            
<br />        self.connect(self.u, self.scale, self.chan_filt,
<br />self.packet_receiver)
<br />
<br />    def _setup_usrp_source(self):
<br />        self.u = usrp2.source_32fc (self._interface, self._mac_addr)
<br />        adc_rate = self.u.adc_rate()
<br />
<br />        # derive values of bitrate, samples_per_symbol, and decim from
<br />desired info
<br />        (self._bitrate, self._samples_per_symbol, self._decim) = \ 
<br />            pick_rx_bitrate(self._bitrate,
<br />self._demod_class.bits_per_symbol(), \
<br />                            self._samples_per_symbol, self._decim, adc_rate) 
<br />
<br />        self.u.set_decim(self._decim)
<br />        # determine the daughterboard subdevice we're using
<br />        #if self._rx_subdev_spec is None:
<br />        #    self._rx_subdev_spec = usrp.pick_rx_subdevice(self.u)
<br />        #self.subdev = usrp.selected_subdev(self.u, self._rx_subdev_spec)
<br />
<br />        #self.u.set_mux(usrp.determine_rx_mux_value(self.u,
<br />self._rx_subdev_spec))
<br />
<br />    def set_freq(self, target_freq):
<br />        """
<br />        Set the center frequency we're interested in.
<br />
<br />        @param target_freq: frequency in Hz
<br />        @rypte: bool
<br />
<br />        Tuning is a two step process.  First we ask the front-end to
<br />        tune as close to the desired frequency as it can.  Then we use
<br />        the result of that operation and our target_frequency to
<br />        determine the value for the digital up converter.
<br />        """
<br />        r = self.u.set_center_freq(target_freq)
<br />        if r:
<br />            return True
<br />
<br />        return False
<br />
<br />    def set_gain(self, gain):
<br />        """
<br />        Sets the analog gain in the USRP
<br />        """
<br />        if gain is None:
<br />            r = self.u.gain_range()
<br />            gain = (r[0] + r[1])/2               # set gain to midpoint
<br />        self.gain = gain
<br />        return self.u.set_gain(gain)
<br />
<br />    def set_auto_tr(self, enable):
<br />        #return self.u.set_auto_tr(enable)
<br />        return
<br />        
<br />    def bitrate(self):
<br />        return self._bitrate
<br />
<br />    def samples_per_symbol(self):
<br />        return self._samples_per_symbol
<br />
<br />    def decim(self):
<br />        return self._decim
<br />
<br />    def carrier_sensed(self):
<br />        """
<br />        Return True if we think carrier is present.
<br />        """
<br />        #return self.probe.level() &gt; X
<br />        return self.probe.unmuted()
<br />
<br />    def carrier_threshold(self):
<br />        """
<br />        Return current setting in dB.
<br />        """
<br />        return self.probe.threshold()
<br />
<br />    def set_carrier_threshold(self, threshold_in_db):
<br />        """
<br />        Set carrier threshold.
<br />
<br />        @param threshold_in_db: set detection threshold
<br />        @type threshold_in_db:  float (dB)
<br />        """
<br />        self.probe.set_threshold(threshold_in_db)
<br />    
<br />        
<br />    def add_options(normal, expert):
<br />        """
<br />        Adds receiver-specific options to the Options Parser
<br />        """
<br />        add_freq_option(normal)
<br />        if not normal.has_option("--bitrate"):
<br />            normal.add_option("-r", "--bitrate", type="eng_float",
<br />default=None,
<br />                              help="specify bitrate.  samples-per-symbol and
<br />interp/decim will be derived.")
<br />        normal.add_option("-e", "--interface", type="string",
<br />default="eth0",
<br />                          help="select Ethernet interface, default is eth0")
<br />        normal.add_option("-m", "--mac-addr", type="string", default="",
<br />                          help="select USRP by MAC address, default is
<br />auto-select")
<br />        #normal.add_option("-R", "--rx-subdev-spec", type="subdev",
<br />default=None,
<br />        #                  help="select USRP Rx side A or B")
<br />        normal.add_option("", "--rx-gain", type="eng_float", default=None,
<br />metavar="GAIN",
<br />                          help="set receiver gain in dB [default=midpoint]. 
<br />See also --show-rx-gain-range")
<br />        normal.add_option("", "--show-rx-gain-range", action="store_true",
<br />default=False, 
<br />                          help="print min and max Rx gain available on
<br />selected daughterboard")
<br />        normal.add_option("-v", "--verbose", action="store_true",
<br />default=False)
<br />        expert.add_option("-S", "--samples-per-symbol", type="int",
<br />default=None,
<br />                          help="set samples/symbol [default=%default]")
<br />        expert.add_option("", "--rx-freq", type="eng_float", default=None,
<br />                          help="set Rx frequency to FREQ
<br />[default=%default]", metavar="FREQ")
<br />        expert.add_option("-d", "--decim", type="intx", default=None,
<br />                          help="set fpga decimation rate to DECIM
<br />[default=%default]")
<br />        expert.add_option("", "--log", action="store_true", default=False,
<br />                          help="Log all parts of flow graph to files
<br />(CAUTION: lots of data)")
<br />        expert.add_option("", "--log-rx-power", action="store_true",
<br />default=False,
<br />                          help="Log receive signal power to file (CAUTION:
<br />lots of data)")
<br />
<br />    # Make a static method to call before instantiation
<br />    add_options = staticmethod(add_options)
<br />
<br />
<br />    def _print_verbage(self):
<br />        """
<br />        Prints information about the receive path
<br />        """
<br />        print "\nReceive Path:"
<br />        print "Using RX d'board %s"    % (self.u.daughterboard_id(),)
<br />        print "Rx gain:         %g"    % (self.gain,)
<br />        print "modulation:      %s"    % (self._demod_class.__name__)
<br />        print "bitrate:         %sb/s" %
<br />(eng_notation.num_to_str(self._bitrate))
<br />        print "samples/symbol:  %3d"   % (self._samples_per_symbol)
<br />        print "decim:           %3d"   % (self._decim)
<br />        print "Rx Frequency:    %s"    %
<br />(eng_notation.num_to_str(self._rx_freq))
<br />        # print "Rx Frequency:    %f"    % (self._rx_freq)
<br />
<br />    def __del__(self):
<br />        # Avoid weak reference error
<br />        #del self.subdev
<br />        return
<br />            
<br />def add_freq_option(parser):
<br />    """
<br />    Hackery that has the -f / --freq option set both tx_freq and rx_freq
<br />    """
<br />    def freq_callback(option, opt_str, value, parser):
<br />        parser.values.rx_freq = value
<br />        parser.values.tx_freq = value
<br />
<br />    if not parser.has_option('--freq'):
<br />        parser.add_option('-f', '--freq', type="eng_float",
<br />                          action="callback", callback=freq_callback,
<br />                          help="set Tx and/or Rx frequency to FREQ
<br />[default=%default]",
<br />                          metavar="FREQ")
<br />
<br />pick_bitrate.py
<br />
<br />#
<br /># Copyright 2005,2006 Free Software Foundation, Inc.
<br /># 
<br /># This file is part of GNU Radio
<br /># 
<br /># GNU Radio is free software; you can redistribute it and/or modify
<br /># it under the terms of the GNU General Public License as published by
<br /># the Free Software Foundation; either version 3, or (at your option)
<br /># any later version.
<br /># 
<br /># GNU Radio is distributed in the hope that it will be useful,
<br /># but WITHOUT ANY WARRANTY; without even the implied warranty of
<br /># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<br /># GNU General Public License for more details.
<br /># 
<br /># You should have received a copy of the GNU General Public License
<br /># along with GNU Radio; see the file COPYING.  If not, write to
<br /># the Free Software Foundation, Inc., 51 Franklin Street,
<br /># Boston, MA 02110-1301, USA.
<br /># 
<br />
<br />_default_bitrate = 500e3
<br />
<br />_valid_samples_per_symbol = (2,3,4,5,6,7)
<br />
<br />def _gen_tx_info(converter_rate):
<br />    results = []
<br />    for samples_per_symbol in _valid_samples_per_symbol:
<br />        for interp in range(16, 512 + 1, 4):
<br />            bitrate = converter_rate / interp / samples_per_symbol
<br />            results.append((bitrate, samples_per_symbol, interp))
<br />    results.sort()
<br />    return results
<br />
<br />def _gen_rx_info(converter_rate):
<br />    results = []
<br />    for samples_per_symbol in _valid_samples_per_symbol:
<br />        for decim in range(8, 256 + 1, 2):
<br />            bitrate = converter_rate / decim / samples_per_symbol
<br />            results.append((bitrate, samples_per_symbol, decim))
<br />    results.sort()
<br />    return results
<br />    
<br />def _filter_info(info, samples_per_symbol, xrate):
<br />    if samples_per_symbol is not None:
<br />        info = [x for x in info if x[1] == samples_per_symbol]
<br />    if xrate is not None:
<br />        info = [x for x in info if x[2] == xrate]
<br />    return info
<br />
<br />def _pick_best(target_bitrate, bits_per_symbol, info):
<br />    """
<br />    @returns tuple (bitrate, samples_per_symbol, interp_rate_or_decim_rate)
<br />    """
<br />    if len(info) == 0:
<br />        raise RuntimeError, "info is zero length!"
<br />
<br />    if target_bitrate is None:     # return the fastest one
<br />        return info[-1]
<br />    
<br />    # convert bit rate to symbol rate
<br />    target_symbolrate = target_bitrate / bits_per_symbol
<br />    
<br />    # Find the closest matching symbol rate.
<br />    # In the event of a tie, the one with the lowest samples_per_symbol
<br />wins.
<br />    # (We already sorted them, so the first one is the one we take)
<br />
<br />    best = info[0]
<br />    best_delta = abs(target_symbolrate - best[0])
<br />    for x in info[1:]:
<br />        delta = abs(target_symbolrate - x[0])
<br />        if delta &lt; best_delta:
<br />            best_delta = delta
<br />            best = x
<br />
<br />    # convert symbol rate back to bit rate
<br />    return ((best[0] * bits_per_symbol),) + best[1:]
<br />
<br />def _pick_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                  xrate, converter_rate, gen_info):
<br />    """
<br />    @returns tuple (bitrate, samples_per_symbol, interp_rate_or_decim_rate)
<br />    """
<br />    if not isinstance(bits_per_symbol, int) or bits_per_symbol &lt; 1:
<br />        raise ValueError, "bits_per_symbol must be an int &gt;= 1"
<br />    
<br />    if samples_per_symbol is not None and xrate is not None:  # completely
<br />determined
<br />        return (float(converter_rate) / xrate / samples_per_symbol,
<br />                samples_per_symbol, xrate)
<br />
<br />    if bitrate is None and samples_per_symbol is None and xrate is None:
<br />        bitrate = _default_bitrate
<br />
<br />    # now we have a target bitrate and possibly an xrate or
<br />    # samples_per_symbol constraint, but not both of them.
<br />
<br />    return _pick_best(bitrate, bits_per_symbol,
<br />                      _filter_info(gen_info(converter_rate),
<br />samples_per_symbol, xrate))
<br />    
<br />#
<br />---------------------------------------------------------------------------------------
<br />
<br />def pick_tx_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                    interp_rate, converter_rate=128e6): 
<br />    """
<br />    Given the 4 input parameters, return at configuration that matches
<br />
<br />    @param bitrate: desired bitrate or None
<br />    @type bitrate: number or None
<br />    @param bits_per_symbol: E.g., BPSK -&gt; 1, QPSK -&gt; 2, 8-PSK -&gt; 3
<br />    @type bits_per_symbol: integer &gt;= 1
<br />    @param samples_per_symbol: samples/baud (aka samples/symbol)
<br />    @type samples_per_symbol: number or None
<br />    @param interp_rate: USRP interpolation factor
<br />    @type interp_rate: integer or None
<br />    @param converter_rate: converter sample rate in Hz
<br />    @type converter_rate: number
<br />
<br />    @returns tuple (bitrate, samples_per_symbol, interp_rate)
<br />    """
<br />    return _pick_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                         interp_rate, converter_rate, _gen_tx_info)
<br />
<br />
<br />def pick_rx_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                    decim_rate, converter_rate=64e6): 
<br />    """
<br />    Given the 4 input parameters, return at configuration that matches
<br />
<br />    @param bitrate: desired bitrate or None
<br />    @type bitrate: number or None
<br />    @param bits_per_symbol: E.g., BPSK -&gt; 1, QPSK -&gt; 2, 8-PSK -&gt; 3
<br />    @type bits_per_symbol: integer &gt;= 1
<br />    @param samples_per_symbol: samples/baud (aka samples/symbol)
<br />    @type samples_per_symbol: number or None
<br />    @param decim_rate: USRP decimation factor
<br />    @type decim_rate: integer or None
<br />    @param converter_rate: converter sample rate in Hz
<br />    @type converter_rate: number
<br />
<br />    @returns tuple (bitrate, samples_per_symbol, decim_rate)
<br />    """
<br />    return _pick_bitrate(bitrate, bits_per_symbol, samples_per_symbol,
<br />                         decim_rate, converter_rate, _gen_rx_info)
<br />
<br />Thanks in advance for your cooperation.</pre><br /><span style="font-size: large;"><b>(2)</b></span><br /><br /><pre>Hi,
<br />
<br />This is what I get when I run benchmark _tx.py and benchmark_rx.py
<br />respectively on USRP2 with transmit_path_usrp2.py and receive_path_usrp2.py
<br />respectively:
<br />
<br />benchmark_tx.py:-
<br />
<br />m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$ sudo
<br />./benchmark_tx.py -f 2400M -v
<br />usrp2::ctor reset_db failed
<br />usrp2::ctor set_rx_gain failed
<br />usrp2::ctor set_tx_interp failed
<br />usrp2::ctor set_rx_scale_iq failed
<br />&gt;&gt;&gt; gr_fir_fff: using SSE
<br />bits per symbol = 1
<br />Gaussian filter bt = 0.35
<br />Using TX d'board 43
<br />Tx amplitude     12000
<br />modulation:      gmsk_mod
<br />bitrate:         500kb/s
<br />samples/symbol:    2
<br />interp:          100
<br />Tx Frequency:    2.4G
<br />...........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$
<br /> 
<br />
<br />benchmark_rx.py:-
<br />
<br />m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$ sudo
<br />./benchmark_rx.py -f 2400M -v
<br />usrp2::ctor reset_db failed
<br />&gt;&gt;&gt; gr_fir_fff: using SSE
<br />bits per symbol = 1
<br />M&amp;M clock recovery omega = 2.000000
<br />M&amp;M clock recovery gain mu = 0.175000
<br />M&amp;M clock recovery mu = 0.500000
<br />M&amp;M clock recovery omega rel. limit = 0.005000
<br />frequency error = 0.000000
<br />
<br />Receive Path:
<br />Using RX d'board 39
<br />Rx gain:         35
<br />modulation:      gmsk_demod
<br />bitrate:         500kb/s
<br />samples/symbol:    2
<br />decim:           100
<br />Rx Frequency:    2.4G
<br />
<br />
<br />Now the same thing for usrp1 but using transmit_path.py and receive_path.py
<br />which is already provided in gnuradio:
<br />
<br />benchmark_tx.py:-
<br />
<br />m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$ sudo
<br />./benchmark_tx.py -f 2400M -v
<br />&gt;&gt;&gt; gr_fir_fff: using SSE
<br />bits per symbol = 1
<br />Gaussian filter bt = 0.35
<br />Using TX d'board A: Flex 2400 Tx MIMO B
<br />Tx amplitude     12000
<br />modulation:      gmsk_mod
<br />bitrate:         500kb/s
<br />samples/symbol:    2
<br />interp:          128
<br />Tx Frequency:    2.4G
<br />...........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$
<br /> 
<br />
<br />benchmark_rx.py:-
<br />
<br />m...@mcrl-desktop:~/gnuradio/gnuradio-examples/python/digital$ sudo
<br />./benchmark_rx.py -f 2400M -v
<br />&gt;&gt;&gt; gr_fir_fff: using SSE
<br />bits per symbol = 1
<br />M&amp;M clock recovery omega = 2.000000
<br />M&amp;M clock recovery gain mu = 0.175000
<br />M&amp;M clock recovery mu = 0.500000
<br />M&amp;M clock recovery omega rel. limit = 0.005000
<br />frequency error = 0.000000
<br />
<br />Receive Path:
<br />Using RX d'board A: Flex 2400 Rx MIMO B
<br />Rx gain:         45
<br />modulation:      gmsk_demod
<br />bitrate:         500kb/s
<br />samples/symbol:    2
<br />decim:            64
<br />Rx Frequency:    2.4G
<br />
<br />I am using the same pick_bitrate.py file that is already provided in
<br />gnuradio. As it can be seen that both usrp systems have the default bit rate
<br />irrespective of whether it acts as receiver or transmitter. My concern is
<br />with the interpolation and decimation. Do I need to make changes to the
<br />pick_bitrate.py file for USRP2? If yes, then what kind of changes. I also
<br />observed that even though USRP2 shows a bit rate of 500kbps, however I
<br />believe that its transmitting too fast which does not allow USRP1 to receive
<br />correctly.I would greatly appreciate any help in this matter.
<br />
<br />Thanks in advance.
<br />
<br /><b><span style="font-size: large;">(3)</span></b></pre><br /><pre>At a minimum, you will need to call pick_tx_bitrate and
<br />pick_rx_bitrate providing proper rates for the ADC and DAC.  They
<br />default to the values appropriate for the USRP1.  However, it looks
<br />like you'll need a USRP2 version since they encode the acceptable
<br />ranges for interpolation and decimation which are different between
<br />the USRP1 and USRP2.
<br />
<br />Eric</pre><br /><b><span style="font-size: large;">(4)</span></b><br /><br /><pre>Hi,
<br />
<br />I already tried to set the value of the converter_rate in pick_tx_bitrate
<br />and Pick_rx_bitrate according to the ADC and DAC specifications of u...@. I
<br />set it to 200e6 in pick_tx_bitrate and in pick_rx_bitrate. But even that did
<br />not worked. I am confused with how to modify the pick_bitrate.py file for
<br />usrp2. I am not able to determine the different parameters that I need to
<br />provide for usrp2. If anyone has already worked on it then please help me to
<br />modify the pick_bitrate file for usrp2. Also if any other changes are
<br />required in other python files.
<br />
<br />Thanks in advance.
<br />
<br />Smith</pre><br /><b><span style="font-size: large;">(5)</span></b><br /><br /><tt>The DAC rate is 100e6.  The &#8220;bitrate&#8221; is the desired data rate of the  </tt><tt>over the air modulation.  It should be MUCH less, like 100k to 1M or so. </tt><br /><tt>There is absolutely nothing in any of the systems for which 200e6 is a  </tt><tt>correct choice. </tt><br /><pre style="margin: 0em;">Matt</pre></div>
</div>

</article>

    </div>
  </div>
  <footer role="contentinfo"><p>
  <a href="https://github.com/creasyw">Qiong Wu</a> &copy;2009-2014 &mdash;
  <span class="credit">Thanks to <a href="http://ayyang.com">Alex Yang</a>, <a href="http://octopress.org/">Octopress</a> and <a href="https://github.com/">Github</a>.</span><br>
  send me an email 
<script type="text/javascript">
var emailriddlerarray=[99,114,101,97,115,121,119,117,113,105,111,110,103,64,103,109,97,105,108,46,99,111,109]
var encryptedemail_id82='' //variable to contain encrypted email 
for (var i=0; i<emailriddlerarray.length; i++)
 encryptedemail_id82+=String.fromCharCode(emailriddlerarray[i])
 document.write('<a href="mailto:'+encryptedemail_id82+'"><img src="/img/email.png" alt="Qiong" /></a>')
</script>
</p>
</footer>
</body>
</html>
