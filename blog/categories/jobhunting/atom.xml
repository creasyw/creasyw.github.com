<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jobhunting | Qiong Wu]]></title>
  <link href="http://creasyw.github.io/blog/categories/jobhunting/atom.xml" rel="self"/>
  <link href="http://creasyw.github.io/"/>
  <updated>2014-07-21T22:50:18-05:00</updated>
  <id>http://creasyw.github.io/</id>
  <author>
    <name><![CDATA[Qiong Wu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[some reflections]]></title>
    <link href="http://creasyw.github.io/blog/2011/03/08/these-days-i-did-lots-of-parallel/"/>
    <updated>2011-03-08T00:00:00-06:00</updated>
    <id>http://creasyw.github.io/blog/2011/03/08/these-days-i-did-lots-of-parallel</id>
    <content type="html"><![CDATA[<div class="post">
These days, I did lots of parallel programming. Although sometimes this activity does suffer from low efficiency, it do help me a lot  for further preparing and studying of coding. Like other routine work,  the more both of us prepared, the more efficient work we will have.  Besides, there are several points worth mentioning in retrospect:<br /><br />1) Format matters. Tab is a much better choice than several blanks. <br />2) Comments also matter. It will help others know why I wrote in this manner and what the underlying idea for some blocks of code.<br />3) Multiple screens are necessary: put severl UI in one screen, references in one, and debug windows in one. Cross referring among different dialogs and different screens is one way to improve efficiency. <br />4) As long as employ oneself in the subject, it will be more  straightforward to achieve goals. After all, coding is only  time-consuming in one aspect.<br />5) The use of short-cuts in vim definitely will improve the efficiency, and also seems like more professional:)<br />6) People will only accept suggestions when they know nothing about it. So, at most of the time, the better choice is just keeping quite and getting your own work done. <br />7) Reading more, practice more, improve faster.<br /><br />Update:<br /><br />Below is something I read from a <a href="http://jacquesmattheij.com/The+need+to+code">programmer's blog</a>.<br /><br /><br />At the time I was a fanatic chess player and my 'dream' was to  build a  chess program. Of course that was a fairly advanced thing to  do, in the  end my knowledge of computer programming, and my theoretical  knowledge  of chess, the memory of the computer, and the available  time, they all  limited me to writing a program that could do one of two  end games (KQ  vs K and KR vs K). <br />Looking back over all those  years (I'm 45 now), I don't think there  ever was a time when I wasn't  programming or thinking about programming  in some way or another since I  gained that first little bit of insight  into what makes a computer  tick.<br /><br />It's like a drug. I'm still fascinated by it, even almost 30  years to  the day later I still read about languages, new ways to solve  old  problems, all kinds of developments in software and hardware, as  though  it is the first time that I hear about these things. It is a  fascinating  world, the world of software. <br />It has changed  tremendously over that time, our 'small' computers of  today are more  powerful than the biggest 'big iron' that you could buy  when I was a  kid. Your average cell phone has more storage, computing  power, and  bandwidth available to it than a mainframe of 30 years ago.  Programming  itself has changed, from 'batch' programming to more and  more  interactive code, 'web' development and so on. But it has also - in   essence - remained the same, small building blocks are piled on top of   each other to create more complex constructs, which in turn can be used   to create yet more complex constructs, and so on.<br /><br />That process, the act of programming, is something that I <i>need</i>   to do. Whether to make a living or to be fooling around with some  idea,  the bug is in my system and I highly doubt that it will ever  leave me  permanently. I can see myself taking a break, but I can't see  myself  ever stopping. All I'll end up doing then is to change my mode  from work  to play and eventually that will lead back to some form of  work.<br /><br />If you can't program yet, or if you think that it is  'complex', rest  assured, there is nothing that can't be learned.  Programming is not like  playing a musical instrument, and it is not  something that you have to  have a genetic disposition for. The pay-off  is in how much time you  spend plugging away at it. Over time you'll get  better, and at some  point it will click. It may take a while (it took  me more than a year to  learn 'BASIC', which is a very simple language)  and I gave up several  times only to go back to it once more.  Eventually, I got it, and I'm  sure that everybody that can do basic  arithmetic and that is able to put  together a precise list of  instructions on how to make coffee or a  pizza can learn how to program.<br /><br />Maybe you won't be the next Donald Knuth, but that's not what it   takes, all you need to be is a little bit better than you were  yesterday  and to keep doing that for a long time.<br /><br />Beware of that bug though, once it bites you, you'll be hooked for life.</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[advices about resume]]></title>
    <link href="http://creasyw.github.io/blog/2011/03/07/advices-about-resume/"/>
    <updated>2011-03-07T00:00:00-06:00</updated>
    <id>http://creasyw.github.io/blog/2011/03/07/advices-about-resume</id>
    <content type="html"><![CDATA[<div class="post">
Reading the articles written by <a href="http://www.joelonsoftware.com/articles/ResumeRead.html">Joel</a> sometimes feels frustrated. But, anyway, they are also illustrated. Here is another post about how to write readable resume:<br />======<br /><br /># Proofread everything a hundred times and have one other person proofread it. Someone who got really good grades in English.<br /><br /># Write a personal cover letter that is customized for the job you are applying for. Try to sound like a human in the cover letter. You want people to think of you as a human being. <br /><br /># Don't apply for too many jobs. I don't think there's ever a reason to apply for more than three or four jobs at a time. Résuméspam, or any sign that you're applying for 100 jobs, just makes you look desperate which makes you look unqualified. You want to look like you are good enough to be in heavy demand. You're going to decide where you want to work, because you're smart enough to have a choice in the matter, so you only need to apply for one or two jobs. A personalized cover letter that shows that you understand what the company does goes a long way to proving that you care enough to deserve a chance. <br /><br /># What we're really looking for when we look at résumés is someone who is passionate and successful at whatever they try to do. We like people who are passionate about software. Writing a shareware app when you're a teenager is just as good a qualification to us as getting into MIT. This is your life story, and by the time you're applying for a job it's probably too late to change that.<br /><br /># The number one best way to get someone to look at your resume closely: come across as a human being, not a list of jobs and programming languages.</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[some basic C/C++ questions]]></title>
    <link href="http://creasyw.github.io/blog/2011/03/04/some-basic-cc-questions/"/>
    <updated>2011-03-04T00:00:00-06:00</updated>
    <id>http://creasyw.github.io/blog/2011/03/04/some-basic-cc-questions</id>
    <content type="html"><![CDATA[<div class="post">
<span id="internal-source-marker_0.4999975798251227" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">1) What are some of the main differences between a linked list and an array?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are faster in access than a link list for random access with index.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are not dynamic while a link list is.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are easier to sort than a link list.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The elements of link list can be deleted/inserted while arrays cannot.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays occupy the same block of memory, while a link list is distributed.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Array objects are automatically created by a compiler, while link lists are not.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are part of most compilers, while link lists are not.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are syntactically simple to read.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">2) What are the differences between struct, class and union?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Struct,  class and union all contain data members and methods. However, a struct  and union have their member’s public by default, while the class  members are private by default. Also, a struct cannot contain an  instance of itself. A union cannot be used as a base class in  inheritance. None of a union's data members can be declared static and  none of its functions can be virtual.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">3) What are virtual functions?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Virtual  functions are functions whose behavior is known at runtime rather than  at compile time. Due to this behavior, it can be said that virtual  functions implement Polymorphism. In other words, preceding a function  name with virtual in the base class means that that function is intended  to be re-implemented (overridden) in the sub-class.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">4) Explain the mechanism of virtual functions and virtual function tables.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Whenever  a class member function is declared as virtual, the compiler creates a  virtual table in memory which contains all function pointers that are  declared as virtual in that class. This enables run time polymorphism  (i.e. finding out the desired function at run time). Virtual function  tables also have an additional pointer in the object to the vtable. As  this additional pointer and the vtable increases the size of the object,  a class designer needs to be judicious about declaring functions  virtual. The sequence of events upon calling a method on the base object  pointer is:</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Get vtable pointer (this vtable pointer points to the beginning of the vtable).</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Get the function pointers in the vtable using offset.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Invoke the function indirectly through the vtable pointer.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">5) Given a singly linked list and a pointer to a certain node in the list, how would you delete that node in constant time?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">First  of all, check if this node is the last node in the list. If not, copy  the contents of the next node to the current node, and delete the next  node.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">6) What are recursive functions? What are the advantages and disadvantages of recursive algorithms?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  function that calls itself repeatedly, satisfying some condition, is  called a Recursive Function. In my point of view, the recursive  functions should be avioded at most of the time via the "while" loop  sentence. However, on the other hand, some problems inherently are  better suited for recursion, such as Fibonacci series generation.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Some  advantages of recursive algorithms are: concise in terms of source  code; and looking more elegant. The disadvantages of recursion include:  requiring more of stack than non-recursive algorithms, due to several  activation stacks for each call of the function; and correcting or  testing recursive functions would require a lot of careful thinking.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">7) What leads to code-bloating in C++?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Inline  functions and templates, if not used properly, may lead to code  bloating. Multiple Inheritance may also lead to code bloating (this is  because the sub classes will end up getting members from all the base  classes even if only few members will suffice).</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Inline  is great. Reasons: They look like functions, they act like functions,  they're ever so much better than macros (Whenever you write a macro, you  have to remember to parenthesize all the arguments in the macro body.  Otherwise you can run into trouble when somebody calls the macro with an  expression. On the contrary, inline funtions do not have that kind of  troubles), and you can call them without having to incur the overhead of  a function call. Moreover, as inlining a function, it may enable  compilers to perform context-specific optimizations on the body of the  function. Most compilers never perform such optimizations on "outlined"  function calls.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">However,  the idea behind an inline function is to replace each call of that  function with its code body, which is likely to increase the size of  your object code. On machines with limited memory, overzealous inlining  can give rise to programs that are too big for the available space. Even  with virtual memory, inline-induced code bloat can lead to additional  paging, a reduced instruction cache hit rate, and the performance  penalties that accompany these things.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Solution:  Initially, don't inline anything, or at least limit your inlining to  those functions that must be inline (eg. functions defined inside a  class which are implicitly declared inline) or are truly trivial (such  as Person::age). By employing inlines cautiously, you facilitate your  use of a debugger, but you also put inlining in its proper place: as a  hand-applied optimization. Don't forget the empirically determined rule  of 80-20, which states that a typical program spends 80% of its time  executing only 20% of its code. It's an important rule, because it  reminds you that your goal as a software developer is to identify the  20% of your code that can increase your program's overall performance.  You can inline and otherwise tweak your functions until the cows come  home, but it's wasted effort unless you're focusing on the right  functions.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">8) What are references in C++? Why do you need them when you have pointers?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Reference  variables are internally implemented as a pointer; it’s just that  programmers can't use it the way they use pointers. As a side note, a  reference must refer to some object at all times, but a pointer can  point to NULL. In this way, references can be more efficient when you  know that you'll always have an object to point to, because you don't  have to check against NULL.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">9)  How do you do dynamic memory allocation in C applications? List  advantages and disadvantages of dynamic memory allocation vs. static  memory allocation.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">In C, malloc, calloc and realloc are used to allocate memory dynamically. In C++, new(), is usually used to allocate objects.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Advantage  is that memory is allocated on an as-needed basis, which helps remove  the inefficiencies inherent to static memory allocation, that is when  the amount of memory needed is not known at compile time and one has to  make a guess.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Disadvantages:  1) dynamic memory allocation is slower than static memory allocation,  because dynamic memory allocation happens in the heap area; 2) dynamic  memory needs to be carefully deleted after use, because they are created  in non-contiguous area of memory segment, and if not properly handled,  the operations would cause memory fragmentation; 3) dynamic memory  allocation causes contention between threads, so it degrades performance  when it happens in a thread.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">10) What are constructors and destructors?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Constructors and destructors are provisions for initialization and cleanup of objects.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  constructor is a special member function with the same name as the  Class. It is invoked automatically when the object is created. It  usually contains initialization code for member variables and allocation  of memory. There can be multiple overloaded constructors, with  different input arguments, used to initialize the object in a variety of  ways.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  destructor is a special member function that is called just before an  object is destroyed. For example, when the object variable goes out of  scope. It is used to perform cleanup. There can be only one destructor.  Its name is ‘~’ followed by the class name.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">11) What happens if an error occurs in a constructor or destructor?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Constructors  don't have a return type, so it's not possible to use error codes. The  best way to signal constructor failure is therefore to throw an  exception. However, keep in mind that the memory for the object itself  is released, and the destructors for all sub-objects (i.e. members and  base classes) whose constructors have successfully run to completion  will be called, which will consquently cause memory leak by the object  pointer.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">12) Differentiate between a copy constructor and an assignment operator.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  copy constructor is used to copy an object to a newly created object.  This is used during initialization and not during ordinary assignment.  The copy constructor is invoked whenever a new object is created and  initialized to an existing object of the same kind.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">In  other words, the assignment operator handles assigning one object to  another of the same class. If a statement creates a new object it is  using initialization. If it alters the value of an existing object it is  assignment.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">13) What are virtual destructors?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Destructor  implemented by declaring a base class’s destructor with the keyword  virtual is called a virtual destructor. A virtual destructor ensures  that, when delete is applied to a base class pointer or reference, it  calls the destructor implemented in the derived class, if an  implementation exists.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Let’s  take the simplest polymorphic relation: A - base class, B - class  derived from A. If we've got a pointer (or reference) to class A, but  under the hood it is an object of type B, and we're trying to delete the  object, declaration of virtual destructor in class A ensures that the  destructor of class B will be called.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">B* b = new B;</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A* a = b //due to polymorphism!</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">delete a; // both A and B destructors are called.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">14)  What is multiple inheritance? What are the potential pitfalls of  multiple inheritance? How would you avoid multiple inheritance?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Deriving  a class from more than one direct base class is called multiple  inheritance. Note that the order of derivation is relevant only to  determine the order of default initialization by constructors and  cleanup by destructors.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Potential  pitfalls of Multiple Inheritance are: 1) Ambiguity; 2) slow; 3) The  “Common Ancestor” problem: For example, if class B and class C derived  from class A and if class D derived from class B and class C, then class  D will have 2 copies of class A that might lead to inconsistency, as  the class doesn't know which copy it is viewing.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">15) What is exception handling? What are the advantages of exception handling?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Exceptions  are an alternative to function return values. The big differences are:  1) Exceptions cannot be ignored. They must be caught or the app will  crash. It is a way of forcing the caller of a function to deal with an  exceptional condition. 2) It is also an improvement over return values,  because you can put all possible values of your return type to good use,  instead of having to dedicate one or more values as the "invalid"  value. 3) In addition, exceptions allow you to jump out of deeply nested  function calls conveniently, avoiding a lot of return type checking and  conditional statements.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">16) What is the difference between new()/delete() and malloc()/free ()?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  main difference is that malloc() and free() don't know anything about  constructors and destructors, where as new and delete do. The following  lists the main differences: 1) new automatically computes the size of  the data object. In malloc you would have to use the sizeof operator. 2)  new automatically returns the correct pointer type. In malloc you would  have to use a type cast. 3) with new you can initialize the object  while creating the object. 4) new and delete can be overloaded. 5) It's  safe to delete a NULL pointer, but you'll get core dump to free a NULL  pointer.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">17) Describe different types of polymorphism available in C++.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">1.  Compile time polymorphism; 2. Runtime Polymorphism. Operator  overloading and Function Overloading are the examples for compile time  polymorphism. Using Virtual Functions we will achieve run time  polymorphism.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Computer Network</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  Internet Protocol (IP) is a key part of the mechanism for transferring  data across the internet. Information is broken into small packets, and  the IP is responsible for relaying and routing them around the system by  identifying and locating hosts. The current version is IPv4, and  because it is made up in sets of 32 bits, it is limited to having just  under 4.3 billion addresses. It seems like a lot but they are almost all  used up.</span></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tree search algorithm (cont.)]]></title>
    <link href="http://creasyw.github.io/blog/2011/03/01/tree-search-algorithm-cont/"/>
    <updated>2011-03-01T00:00:00-06:00</updated>
    <id>http://creasyw.github.io/blog/2011/03/01/tree-search-algorithm-cont</id>
    <content type="html"><![CDATA[<div class="post">
&nbsp;The previous post is <a href="http://creasywuqiong.blogspot.com/2011/02/tree-search-algorithms.html">here</a><br />============ <br />struct treeNode{<br />&nbsp;&nbsp;&nbsp; int element;<br />&nbsp;&nbsp;&nbsp; struct treeNode *left;<br />&nbsp;&nbsp;&nbsp; struct treeNode *right;<br />}:<br />typedef struct treeNode *searchTree;<br /><br /><br />searchTree makeEmpty(searchTree T){<br />&nbsp;&nbsp;&nbsp; if(T!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MakeEmpty(T-&gt;left);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MakeEmpty(T-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; free(T);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return NULL;<br />}<br /><br /><br />searchTree findVal(int val, searchTree T){<br />&nbsp;&nbsp;&nbsp; if(T==NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; if(val<t->element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return findVal(val, T-&gt;left);<br />&nbsp;&nbsp;&nbsp; else if(val&gt;T-&gt;element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return findVal(val, T-&gt;right);<br />&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return T;<br />}<br /><br /><br />searchTree findMin(searchTree T){<br />&nbsp;&nbsp;&nbsp; if(T!=NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while(T-&gt;left!=NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = T-&gt;left;<br />&nbsp;&nbsp;&nbsp; return T;<br />}<br /><br /><br />searchTree insertVal(int val, searchTree T){<br />&nbsp;&nbsp;&nbsp; if(T==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T=(searchTree)malloc(sizeof(struct treeNode));<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(T==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("Error! There is no new memory to allocate.\n");<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; exit(0);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;element = val;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;left = T-&gt;right = NULL;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(val<t->element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;left = insertVal(val, T-&gt;left);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if(val&gt;T-&gt;element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;right = insertVal(val, T-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("The element has already in this tree.\n");<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return T;<br />}<br /><br /><br />searchTree deleteVal( int val, searchTree T){<br />&nbsp;&nbsp;&nbsp; searchTree temp;<br />&nbsp;&nbsp;&nbsp; if(T==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("The element is not found.\n");<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else if(val<t->element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;left = deleteVal(val, T-&gt;left);<br />&nbsp;&nbsp;&nbsp; else if(val&gt;T-&gt;element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;right = deleteVal(val, T-&gt;right);<br />&nbsp;&nbsp;&nbsp; else{&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // here, find the specific element<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(T-&gt;left &amp;&amp; T-&gt;right){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = findMin(T-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;element = tmp-&gt;element;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T-&gt;right = deleteVal(tmp-&gt;element, T-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = T;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(T-&gt;left == NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = T-&gt;right;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if(T-&gt;right==NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = T-&gt;left;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; free(temp);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return T;<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br />// the functions below returns node which element is closest<br />// and larger in the Tree. We could call it "next"<br />// assumption1: the inputs are inquiry val and the root node<br />searchTree nextLarger(int val, searchTree T){<br />&nbsp;&nbsp;&nbsp; searchTree temp;<br />&nbsp;&nbsp;&nbsp; if(T==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("There is no tree.\n");<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; if(val<t->element){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(T-&gt;left!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = T-&gt;left;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while(val<temp->element &amp;&amp; temp-&gt;left!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = temp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = temp-&gt;left;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // This case indicate "temp-&gt;left==NULL" causes stop<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // so temp should be the return value<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(val<temp->element)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = temp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // otherwise, result might in a new right tree<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // . or the parent node in this layer<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (temp-&gt;right!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; temp = nextLarger(val, temp-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (temp!=NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = temp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return T;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while(val&gt;=T-&gt;element &amp;&amp; T-&gt;right!=NULL)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = T-&gt;right;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(val<t->element){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; T = nextLarger(val, T);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return T;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br /><br />// assumption2: the input value is a given node in the tree.<br />// In this case, we might have to trace back.<br />// As a resutl, the original struct needs a little modification<br />struct treeNode{<br />&nbsp;&nbsp;&nbsp; int element;<br />&nbsp;&nbsp;&nbsp; struct treeNode *left;<br />&nbsp;&nbsp;&nbsp; struct treeNode *right;<br />&nbsp;&nbsp;&nbsp; struct treeNode *parenet;&nbsp;&nbsp;&nbsp; // to trace back<br />}:<br />typedef struct treeNode *searchTree;<br /><br />searchTree nextLarger2(searchTree start){<br />&nbsp;&nbsp;&nbsp; searchTree temp, record;<br />&nbsp;&nbsp;&nbsp; if(start==NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("There is not a valid input.\n");<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; if(start-&gt;right!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start = findMin(start-&gt;right);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return start;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else if(start-&gt;parent!=NULL){<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(start == start-&gt;parent-&gt;left)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return start;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while(start-&gt;parent!=NULL &amp;&amp; start!=start-&gt;parent-&gt;left)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; start = start-&gt;parent;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(start==start-&gt;parent-&gt;left)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return start;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return NULL;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />}</t-></temp-></temp-></t-></t-></t-></t-><br /><t-><t-><t-><t-><temp-><temp-><t-><br /></t-></temp-></temp-></t-></t-></t-></t-><br /><t-><t-><t-><t-><temp-><temp-><t-> // references: &lt;<a href="http://www.amazon.com/Introduction-Algorithms-Third-Thomas-Cormen/dp/0262033844/ref=sr_1_1?ie=UTF8&amp;qid=1299041213&amp;sr=8-1">Introduction to algorithms</a>&gt;, &lt;<a href="http://www.amazon.com/Cracking-Coding-Interview-Fourth-Programming/dp/145157827X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1299041239&amp;sr=1-1">Coding Interviews</a>&gt; </t-></temp-></temp-></t-></t-></t-></t-><br /><br /><t-><t-><t-><t-><temp-><temp-><t->// I just did some terrible interviews these days. Yes, some, and terrible.<br />// So, I wanna record everything here,&nbsp;</t-></temp-></temp-></t-></t-></t-></t-><br /><t-><t-><t-><t-><temp-><temp-><t->// no matter how stupid and rudimentary it is.<br />// Also as a means to push myself, everyday a step further.<br /></t-></temp-></temp-></t-></t-></t-></t-></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[backup: interview summary]]></title>
    <link href="http://creasyw.github.io/blog/2010/10/29/backup-interview-summary/"/>
    <updated>2010-10-29T00:00:00-05:00</updated>
    <id>http://creasyw.github.io/blog/2010/10/29/backup-interview-summary</id>
    <content type="html"><![CDATA[<div class="post">
谷歌笔试：<br />1.<br />n支队伍比赛，分别编号为0，1，2。。。。n-1，已知它们之间的实力对比关系，存储在一个二维数组w[n][n] 中，w[i][j]<br />的值代表编号为i，j的队伍中更强的一支 所以w[i][j]=i 或者j，现在给出它们的出场顺序，并存储在数组order[n]中，<br />比如order[n] = {4,3,5,8,1......}，那么第一轮比赛就是 4对3， 5对8。。。。。。<br />胜者晋级，败者淘汰，同一轮淘汰的所有队伍排名不再细分，即可以随便排，<br />下一轮由上一轮的胜者按照顺序，再依次两两比，比如可能是4对5,直至出现第一名<br />编程实现，给出二维数组w，一维数组order 和 用于输出比赛名次的数组result[n]，求出result<p><br />2.题目说的比较花哨，根据我的理解，本质上就是有n个长为m+1的字符串，如果某个字符串的最后m个字符与某个字符串的前m个字符匹配，则两个字符串可以联接，问这n个字符串最多可以连成一个多长的字符串，如果出现循环，则返回错误<p>百度面试：<p>3.<br />用天平（只能比较，不能称重）从一堆小球中找出其中唯一一个较轻的，使用x次天平 最多可以从y个小球中找出较轻的那个，求y与x的关系式<br />4.有一个很大很大的输入流，大到没有存储器可以将其存储下来，而且只输入一次，如何从这个输入流中随机取得m个记录<br />5.大量的URL字符串，如何从中去除重复的，优化时间空间复杂度<p>网易有道笔试：<br />6. 求一个二叉树中任意两个节点间的最大距离，两个节点的距离的定义是<br />这两个节点间边的个数，比如某个孩子节点和父节点间的距离是1，和相邻兄弟节点间的距离是2，优化时间空间复杂度<br />7.求一个有向连通图的割点，割点的定义是，如果除去此节点和与其相关的边，有向图不再连通，描述算法<p>discussion can be found @:<br /><a href="http://topic.csdn.net/u/20100930/13/9f10c56c-9545-488e-9b53-edffc9b6761d.html">http://topic.csdn.net/u/20100930/13/9f10c56c-9545-488e-9b53-edffc9b6761d.html</a><p>==========<p>GOOGLE今天晚上的笔试题，刚参加回来.<p>第一题比较简单，检测同一个平面上的两个矩形是否重合<p>第二题是，给定一个随机函数，对一个数组进行随机排列，保证所有可能的排列出现的概率相等，也就是n!分之一<p><br />第三题就是约瑟夫问题的最优解法~Knuth具体数学上有，不过我忘记了，自己没推导出来，就写了个模拟<p>discussion can be found @:<br /><a href="http://topic.csdn.net/u/20101018/23/75b6dc53-610f-401e-b8ae-5aebee5cabe8.html">http://topic.csdn.net/u/20101018/23/75b6dc53-610f-401e-b8ae-5aebee5cabe8.html</a><p>==========<p>雅虎：<br />1.对于一个整数矩阵，存在一种运算，对矩阵中任意元素加一时，需要其相邻（上下左右）某一个元素也加一，现给出一正数矩阵，判断其是否能够由一个全零矩阵经过上述运算得到。<p>2.一个整数数组，长度为n，将其分为m份，使各份的和相等，求m的最大值<br />比如{3，2，4，3，6} 可以分成{3，2，4，3，6} m=1;<br />{3,6}{2,4,3} m=2<br />{3,3}{2,4}{6} m=3 所以m的最大值为3<p>搜狐：<p>3.四对括号可以有多少种匹配排列方式？比如两对括号可以有两种：（）（）和（（））<p>创新工场：<p>4.求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}<p>微软：<br />5.一个数组是由一个递减数列左移若干位形成的，比如{4，3，2，1，6，5}是由{6，5，4，3，2，1}左移两位形成的，在这种数组中查找某一个数。<p>discussion can be found @:<br /><a href="http://topic.csdn.net/u/20101021/14/7fdbcd52-3ee6-42ce-b48e-8fb56c4418da.html">http://topic.csdn.net/u/20101021/14/7fdbcd52-3ee6-42ce-b48e-8fb56c4418da.html</a><p>==========<p>雅虎：<br />1.对于一个整数矩阵，存在一种运算，对矩阵中任意元素加一时，需要其相邻（上下左右）某一个元素也加一，现给出一正数矩阵，判断其是否能够由一个全零矩阵经过上述运算得到。<p>2.一个整数数组，长度为n，将其分为m份，使各份的和相等，求m的最大值<br />比如{3，2，4，3，6} 可以分成{3，2，4，3，6} m=1;<br />{3,6}{2,4,3} m=2<br />{3,3}{2,4}{6} m=3 所以m的最大值为3<p>搜狐：<p>3.四对括号可以有多少种匹配排列方式？比如两对括号可以有两种：（）（）和（（））<p>创新工场：<p>4.求一个数组的最长递减子序列 比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，4，3，2}<p>微软：<br />5.一个数组是由一个递减数列左移若干位形成的，比如{4，3，2，1，6，5}是由{6，5，4，3，2，1}左移两位形成的，在这种数组中查找某一个数。<p>discussion can be found @:<br /><a href="http://topic.csdn.net/u/20101021/14/7fdbcd52-3ee6-42ce-b48e-8fb56c4418da.html">http://topic.csdn.net/u/20101021/14/7fdbcd52-3ee6-42ce-b48e-8fb56c4418da.html</a>
</p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></div>
]]></content>
  </entry>
  
</feed>
