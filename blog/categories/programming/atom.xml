<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Qiong Wu]]></title>
  <link href="http://creasyw.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://creasyw.github.io/"/>
  <updated>2013-09-13T23:02:25-05:00</updated>
  <id>http://creasyw.github.io/</id>
  <author>
    <name><![CDATA[Qiong Wu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reading note of SICP (4)]]></title>
    <link href="http://creasyw.github.io/blog/2013/08/10/reading-note-of-sicp-4/"/>
    <updated>2013-08-10T00:00:00-05:00</updated>
    <id>http://creasyw.github.io/blog/2013/08/10/reading-note-of-sicp-4</id>
    <content type="html"><![CDATA[<div class='post'>
  Aug. 10th. Complete the 1st chapter of sicp.<br/><br/>
  
  I really appreciate the exercises within each subsections, because I can feel that they are well designed. I used to have the same feeling when I did the homework from Dan's course of programming languages. The exercises make the general concepts concrete and doable.
  <br/><br/>
  The abstraction is far from merely making the code more structured and readable. It is a design choice. Sometimes, it takes experience to find out where should be abstracted. And sometimes, it takes much more endeavors than simply mix everything together. But once the choice of abstraction is right, the program becomes clearer, and it increases many degrees of freedom for the design afterwards.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading note of SICP (3)]]></title>
    <link href="http://creasyw.github.io/blog/2013/08/08/reading-note-of-sicp-3/"/>
    <updated>2013-08-08T00:00:00-05:00</updated>
    <id>http://creasyw.github.io/blog/2013/08/08/reading-note-of-sicp-3</id>
    <content type="html"><![CDATA[<div class='post'>
&nbsp;<br />At the end of the 1st chapter, it enumerates the basic reason for the powerful lisp: first-order procedure.<br /><br />The major "privileges" of the first-order elements are:<br />1) They may be named by variables.<br />2) They may be passed as arguments to procedures.<br />3) They may be returned as the results of procedures.<br />4) They may be included in data structures.<br />They can be crucial abstraction mechanism permitting to express the general methods of computing as explicit elements in programming language, so that they can be handled just like other computational elements. The expression power is enormous.<br /><br />I have already been used to use the first two kinds of procedures, but the last two actually make the program even more expressive and powerful. Those are also the attractive properties sharing among functional programming languages.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading note of SICP (2)]]></title>
    <link href="http://creasyw.github.io/blog/2013/08/07/reading-note-of-sicp-2/"/>
    <updated>2013-08-07T00:00:00-05:00</updated>
    <id>http://creasyw.github.io/blog/2013/08/07/reading-note-of-sicp-2</id>
    <content type="html"><![CDATA[<div class='post'>
<br />While I am reading, I always try to distinguish which part of thoughts I used to learn from here when I read it for the first time, and which part I learned from Dan's course. And, surprisingly enough, I learned almost all basic factors from Dan, though I always felt I learned a lot of things last year when I began to read it.<br /><br />The name of this book is perfect for the content -- Structure and Interpretation of Computer Programs. It does not teach about how to program, nor a specific programming language. Of course it is a legacy book. But it seems to me that I cannot get enough from this book unless I have mastered quite a few programming languages. After Dan taught me everything about basic aspects of programming languages and I played with Ruby and Racket for a long time, even after I leaned all those "nontrivial" trivial things about C++, when I read it now, I am able to distinguish which part is the essence and which part is written just for the ease of learning, and I can fully focus on how to put different abstractions into different layers-- in other words, learning the structure and interpretation of computer programs.<br /><br />I read a comment, saying that Chapter 4 and 5 are the essence of the book. Hopefully, I can finish reading it before September, and leave enough time for Design Patterns.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading note of SICP]]></title>
    <link href="http://creasyw.github.io/blog/2013/08/06/reading-digest-sicp/"/>
    <updated>2013-08-06T00:00:00-05:00</updated>
    <id>http://creasyw.github.io/blog/2013/08/06/reading-digest-sicp</id>
    <content type="html"><![CDATA[<div class='post'>
P59. I still don't think it is necessary to use "square" instead of (* x x) everywhere we perform this operation, but I appreciate the idea of "abstraction". It is really a good idea (and practice) to abstract concepts in different levels and use them accordingly.<br /><br />Most of the examples I read are in a top-down design manner: firstly use the abstract concepts, and then implement it in a lower level. The concerns for specific lower-level modules is similar to the way I did using unit test. But I am a little bit confuse how to perform the unit test in this manner. Especially for the closure using in LISP--implementing local helper functions right after building major function-- how can I make sure the helper functions are right before I run the program as a whole? If I separate a helper function as an independent one, it seems that quite a little redundant work has to perform when I move it back to the major function.<br /><br />Anyway, SICP just makes me love Racket even more =D<br /><br />cheers,</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory Management in Obj C]]></title>
    <link href="http://creasyw.github.io/blog/2011/12/19/memory-management-in-obj-c/"/>
    <updated>2011-12-19T00:00:00-06:00</updated>
    <id>http://creasyw.github.io/blog/2011/12/19/memory-management-in-obj-c</id>
    <content type="html"><![CDATA[<div class='post'>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <br />I just complete my 2nd iOS homework, which took me cumulative 40 hours. The part that impressed (or... baffled...) me most is about dealing with memory management. In one scree, I opened the Xcode IDE, and in another screen, I just cross-referenced StackOverflow, Developer Library, and Google searching over and over again. There was no one-stop solution for all of the problems I met. But it only made me feel more enjoyable when I finally found the path to solution:) In case that I might forget the key points all I have collected, I record them here with references.<br /><br />1. <a href="http://stackoverflow.com/questions/3789684/objective-c-checking-if-object-is-undefined-or-nil">Declaration of object</a>. <br /><code>MyObject* myObject;</code><br /><b style="color: red;">WRONG! </b>This means myObject points to a chunk of garbage memory, which would not correctly work at all. Basically, there are two ways to do this correctly:<br /><code>MyObject* myObject=nil;<br />MyObject* myObject=[[MyObject alloc] init];&nbsp;</code><br />The former one makes myObject to point to nothing. Now it at least consistently does nothing, or I could use this pointer points to some useful object later on. But this will also lends to another issue about the life-cycle of a object which I will talk about in detail later. The latter one is to allocate a MyObject object in the memory, initialize it, and then make myObject point to the chunk of memory correctly allocated and initialized. Now, if the MyObject has the interface<br /><code>@interface MyObject:NSObject{<br />&nbsp;&nbsp;&nbsp; NSString* string;<br />}<br /><br />@end<br /><br />@implementation MyObject<br />-(id) init {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(self=[super init]){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...do something ...<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self;<br />}<br /></code><br />after [super init] is successfully performed, Objective-C guarantees that the ivar string is set to nil, i.e. string points to nothing. But it is not that an NSString is allocated or initialized.<br /><br />2. Basic rules about ownership&nbsp; and memory management:<br /><ul><li>Any object returned by <i><b>alloc</b></i>, <i><b>copy</b></i>, <i><b>copyWithZone</b></i>, or <i><b>new</b></i> has a retain count of 1.</li><li><i><b>retain</b></i> increases the receiving object's retain count.</li><li><i><b>release</b></i> decreases the receiving object's retain count.</li><li><i><b>autorelease</b></i> tells the current autorelease pool to send the receiving object the release message “later”.</li><li>Any factory method that doesn't have “new” or “copy” in the name (e.g., stringWithString:) returns an object that it has autoreleased on your behalf.</li><li>Conversely, if you are not the creator of an object and have not expressed an ownership interest, you must not release it. </li></ul>Or, digested a bit:<br /><ul><li>Any method whose name contains copy, alloc, retain, or new returns an object that you own.</li><li>Any method that doesn't, returns an object that you don't own.</li><li>To own an object, retain it.</li></ul><br />Reference: <a href="http://stackoverflow.com/questions/318666/object-ownership-in-stringwithstring-and-initwithstring-in-nsstring">StackOverflow,</a> <a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html">Developer Library</a>. <a href="http://www.otierney.net/objective-c.html#retain">An example about <b><i>retain</i></b> and <b><i>release</i></b></a>, and <a href="http://stackoverflow.com/questions/3262575/alloc-init-with-synthesized-property-does-it-cause-retain-count-to-increase">another deeper discussion</a>. <br /><br />3. <i><b>copy</b></i> versus <i><b>retain</b></i><br /><br />There are lots of discussions about the subtle differences between these two operations, though they both intend to take the ownership from the acquired objects. "<a href="http://vgable.com/blog/2008/11/14/prefer-copy-over-retain/">(Almost) every time you use retain in Objective-C/Cocoa, you really should be using copy. Using retain can introduce some subtle bugs, and copy is faster then you think…</a>" The problem with using retain to “take ownership” of an object is that someone else has a pointer to the same object, and if they change it, you will be affected.<br /><br />There are some other discussions concerning the same kind of problem in <a href="http://stackoverflow.com/questions/387959/nsstring-property-copy-or-retain/388002#388002">StackOverflow</a> and <a href="http://robnapier.net/blog/implementing-nscopying-439">post in a blog</a>. Besides, I also made to rookie mistakes that took me quite a while to find out and correct.<br /><br />4. <a href="http://stackoverflow.com/questions/3488446/is-a-synthesized-property-already-alloc-init-ed">Has a @synthesize property already init &amp; alloc-ed?</a><br /><br />The answer is NO. It needs to populate the property manually. The exception is if you have an IBOutlet property that you've connected in a nib file; that will get populated automatically when the nib is loaded.<br /><br />For view controllers, the vast majority of properties are IBOutlets and properties that describe what the view will show, and the latter case is usually set by the object that creates the view controller. That will usually be the case for a view controller that shows a detail view for some object.<br /><br />If you do have properties that are completely local to the view controller, a common pattern is to write your own getter and setter (rather than using @synthesize) and create the object in the getter if it doesn't exist. This lazy-loading behavior means you can easily free up resources in low-memory conditions, and that you only pay the cost of loading an object when you need it.<br /><code>// simple lazy-loading getter<br />- (MyPropertyClass*) propertyName {<br />&nbsp;&nbsp;&nbsp; if(propertyIvarName == nil) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; propertyIvarName = [[MyPropertyClass alloc] init];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ......&nbsp; // ... other setup here<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return propertyIvarName;<br />}</code><br /><br />5. Pitfall about the use of getter/setter:<br /><code>@interface MyObject:NSObject{<br />&nbsp;&nbsp;&nbsp; NSString *aString;<br />}<br />@property (nonatomic, copy) NSString *aString;<br />- (void) someMethod; <br />@end<br /><br />@ implementation MyObject {<br />@synthesize aString;<br />- (id) init {<br />&nbsp;&nbsp;&nbsp; ......<br />}<br />- (void) someMethod {<br />&nbsp;&nbsp;&nbsp; ......<br />&nbsp;&nbsp;&nbsp; aString = [NSString stringWithString: @"blah, blah, blah."];<br />&nbsp;&nbsp;&nbsp; aString = [[NSString stringWithString: @"blah, blah, blah."] retain];<br />&nbsp;&nbsp;&nbsp; aString = [[NSString stringWithString: @"blah, blah, blah."] copy]; <br />&nbsp;&nbsp;&nbsp; self.aString = [NSString stringWithString: @"blah, blah, blah."];<br />&nbsp;&nbsp;&nbsp; ......<br />}<br /></code><br />The compiler would not pop up any warning or error about the code above. But the 1st line in the method is extremely dangerous as well as a bug hard to find: the aString does not own the returned object, which will be released at some time after the method is completed. Corresponding to the second factor that I write above, it is obvious that this sentence has no keywords about ownership. Worse still, although the ownership is considered in the <i>@property</i>, this sentence does not call the setter method. The right way to activate the setter is the 4th sentence. Besides, the 2nd and 3rd sentence request the ownership of the new object in another form. They are legal, of course.<br /><br />[ UPDATE:<br /><br />6. <i>viewDidUnload</i> vs. <i>dealloc</i><br /><br />Unless the program needs to break a retain cycle, it should generally only be releasing objects in the <i>dealloc</i> method. <i>viewDidUnload</i> is an <b>exception</b>; it is invoked in low memory situations and should be used to release anything useless. Then, a preferable way to do this is to write another <i>releaseMemory</i> function where takes most or all of the used objects into consideration and sets them into <i>nil</i>, and then to call this function both in <i>viewDidUnload</i> and <i>dealloc</i>.<br /><br />The general principle is just as mentioned above: if you do need to release them anywhere else, then always set the reference to nil after the release. That will protect the app from blowing up later (likely in dealloc).<br /><br />References: <a href="http://stackoverflow.com/questions/2353321/release-in-viewdidunload-and-dealloc-both">StackOverFlow-1</a>, <a href="http://stackoverflow.com/questions/1768076/are-viewdidunload-and-dealloc-always-called-when-tearing-down-a-uiviewcontroller">StackOverFlow-2</a>. <br />]<br /><br />It is glad that I have gone this far. And, I will move on,&nbsp; and dig deeper.<br /><br />cheers.</div>

]]></content>
  </entry>
  
</feed>
