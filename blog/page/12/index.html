
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Qiong Wu</title>
  <meta name="author" content="Qiong Wu">

  
  <meta name="description" content="将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须一致。迭代器first和last如果满足以下两点，则可以形成一个迭代器范围：1、它们指向同一个容器中的元素或超出末端的下一个位置；如果两个迭代器不相等，则对first反复应用自增加运算必须能够到达last，即， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://creasyw.github.io/blog/page/12/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <!-- add Mathjex.js by qiong -->
  <script src="http://kramdown.rubyforge.org/MathJax/MathJax.js" type="text/javascript"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="./atom.xml" rel="alternate" title="Qiong Wu" type="application/atom+xml">
  
  <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  
  
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Qiong Wu</a></h1>
  <!--
  
    <h2>A blogging framework for hackers.</h2>
  
  -->
</hgroup>
</header>
  <nav role="navigation"><!--
<ul class="subscription" data-subscription="rss">
  <li><a href="./atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:creasyw.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

-->

<ul class="main-navigation">
  <!--<li><a class="yellow" href="/">Hello</a></li>-->
  <li><a class="github" href="/blog/archives/">Blog</a></li>
  <li><a class="github" href="/tags">Tags</a></li>
  <li><a class="github" href="http://www.github.com/creasyw">Github</a></li>
  <li><a class="github" href="https://twitter.com/creasywuqiong">Twitter</a></li>
  <li><a class="github" href="/rss">RSS</a></li>
</ul>


</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/07/01/20100701-digest-container/">Digest: Container</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-01T00:00:00-05:00" pubdate data-updated="true">Jul 1<span>st</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须一致。<br /><br />迭代器first和last如果满足以下两点，则可以形成一个迭代器范围：1、它们指向同一个容器中的元素或超出末端的下一个位置；如果两个迭代器不相等，则对first反复应用自增加运算必须能够到达last，即，务必在使用前检查last绝对不能位于first之前。<br /><br />使用迭代器时，通常可以编写程序使得要求迭代器有效的代码范围较短。然后，在该范围内，严格检查每一条语句，判断是否有元素增加或者删除，从而相应的调整迭代器的值。此外，任何insert、push、assign操作都会导致原迭代器失效。当编写循环将元素插入到vector或deque容器中时，程序必须确保迭代器在每次循环后都得到更新。<br />vector&#8221;int&#8221;<int>::iterator first = v.begin(); //cache begin iterator<br />//safer: recalaulate end on each trip whenever the loop adds/erases elements<br />while (first != v.end()) { &nbsp;//do some processing in block&#8230;<br />&nbsp;&nbsp; &nbsp; //insert new value, meanwhile update the first iterator<br />&nbsp;&nbsp; &nbsp; first = v.insert(first, 42);<br />&nbsp;&nbsp; &nbsp; ++first; &nbsp; &nbsp;//advance first just past the element added just now<br />&nbsp;&nbsp; &nbsp; } &nbsp; &nbsp;//example ends<br />&nbsp;&nbsp; <br />在调用front或back函数之前，或者在对begin或end返回的迭代器进行解引用运算之前，必须保证容器非空。例如，进行 if(!ilist.empty()){&#8230;}的检查，否则，上述四个语句的操作都是没有定义的。</int><br /><br /><int></int>如果程序要求随机访问元素，则应使用vector或deque容器；如果程序必须在容器中间位置插入或者删除元素，则应采用list容器。如果无法确定某种应用应当采取哪种容器，则编写代码时应尝试只使用vector和list容器都提供的操作：使用迭代器，而不是下表，并且避免随机访问元素。这样编写代码，在必要的时候，可以很方便将程序从使用vector修改为使用list容器。</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/30/complangc-is-good-place/">comp.lang.c Is a Good Place:)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-30T00:00:00-05:00" pubdate data-updated="true">Jun 30<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
Q: I&#8217;m trying to define a few simple little function-like macros such as<br /><span class="Apple-tab-span" style="white-space: pre;">      </span>#define square(x) x * x<br />but they&#8217;re not always working.<br />&#8212;&#8212;&#8212;-<br />A: <b>There are three important rules to remember when defining function-like macros</b>:<br />The macro expansion must always be parenthesized to protect any lower-precedence operators from the surrounding expression. Given the (incorrect) square() macro above, the invocation<br /><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span><span class="Apple-style-span" style="white-space: pre;">      </span>1 / square(n)<br />would expand to<br /><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span><span class="Apple-style-span" style="white-space: pre;">      </span>1 / n * n<br />(which evaluates as (1 / n) * n), while what you want is<br /><span class="Apple-tab-span" style="white-space: pre;">       </span>1 / (n * n)<br />(In this case, the problem is one of associativity rather than precedence, but the effect is the same.)<br />Within the macro definition, all occurrences of the parameters must be parenthesized to protect any low-precedence operators in the actual arguments from the rest of the macro expansion. Again given the square() macro above, the invocation<br /><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span><span class="Apple-style-span" style="white-space: pre;">      </span>square(n + 1)<br /><span class="Apple-tab-span" style="white-space: pre;"></span><br />would expand to<br /><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span><span class="Apple-style-span" style="white-space: pre;">      </span>n + 1 * n + 1<br /><span class="Apple-tab-span" style="white-space: pre;"></span><br />But what you want is<br /><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span><span class="Apple-style-span" style="white-space: pre;">      </span>(n + 1) * (n + 1)<br /><span class="Apple-tab-span" style="white-space: pre;"></span><br />If a parameter appears several times in the expansion, the macro may not work properly if the actual argument is an expression with side effects. Yet again given the square() macro above, the invocation<br /><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span><span class="Apple-style-span" style="white-space: pre;">      </span>square(i++)<br />would expand to<br /><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span><span class="Apple-style-span" style="white-space: pre;">      </span>i++ * i++<br />which is undefined (see question 3.2).<br />The proper definition of a square macro, to comply with rules 1 and 2 above, is<br /><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span><span class="Apple-style-span" style="white-space: pre;">      </span>#define square(x) ((x) * (x))<br /><span class="Apple-tab-span" style="white-space: pre;"></span><br />Complying with rule 3 is harder. Sometimes, careful exploitation of the short-circuiting behavior of the &amp;&amp;, ||, or ?: operators (see question 3.6) can arrange that a parameter which appears several times is guaranteed to be evaluated exactly once. Sometimes, the macro is just documented as being unsafe, and callers must remember not to use it on arguments with side effects. Other times, it may be advisable not to compose a function-like macro if it can&#8217;t be made safe.<br />(As a stylistic convention, macros are often defined with capitalized or all-upper-case names, to make it obvious that they are macros. It may be acceptable to define a function-like macro with an all-lower-case name, if it truly simulates a function, but only if it complies with all three rules above. Since the squaring macro we&#8217;ve been discussing does not, it should be defined as something like<br /><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span><span class="Apple-style-span" style="white-space: pre;">      </span>#define Square(x) ((x) * (x))<span class="Apple-tab-span" style="white-space: pre;"> </span>/* UNSAFE */<br />if it is to be used at all.)<br /><br />References: K&amp;R1 Sec. 4.11 p. 87<br />K&amp;R2 Sec. 4.11.2 p. 90<br />H&amp;S Secs. 3.3.6,3.3.7 pp. 49-50<br />CT&amp;P Sec. 6.2 pp. 78-80<br /><a href="http://groups.google.com/group/comp.lang.c/browse_thread/thread/57175d098e52a10d?hl=en">original question</a></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/29/study-digest-standard-library-functions/">Study Digest: Standard Library Functions</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-29T00:00:00-05:00" pubdate data-updated="true">Jun 29<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
C vs. C++ 其中一个显式区别，就是后者增添了标准库类型，vector、string、bitset。<br /><br />以vector为例，实际上可将其看成是一个可变长度的数组，迭代器类比于增强版本的指针。而标准库函数最大的好处在于其成员函数，可以轻松地完成一些在C语言中需要特定代码段完成的功能。并且，就安全性而言，vector的迭代器也不必处处小心诸如指针初始化、或者指针越界之类的隐藏错误。<br /><br />而标准库函数中的string，比C语言中处理字符的char*，在实际应用中限制也更少。主要问题仍然是，C语言将字符串作为数组处理，则合并、拷贝时，必须考虑到起始点以及总长度的问题，这也就造成了代码块的可移植性受到了很大的限制。而C++不存在这样的问题，因为其语言的标准库处理所有的内存管理问题。只要在开始阶段定义了string型变量，则接下来的操作和一般的变量赋值加减的操作无异了。此外，C风格字符串一个更严重的缺陷在于默认null结尾字符的存在，strlen的返回值必须加一才是整个数组的真正长度，这样的细微之处很可能在数组操作时成为一个隐患。<br /><br />标准库提供的bitset操作，更直接，更容易阅读和书写、正确使用的可能性更高。而且，bitset对象的大小不受unsighed数的位数限制。通常来说，bitset优于整型数据的低级直接位操作。<br /><br />综上，C语言风格的内置数组和C++标准库函数相比，更易于出错，更难于理解难于调试，。所以除非是在极端要求代码执行速度的情况，否则使用C++的标准库函数更好。</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/28/digest-four-important-data-type-in-c/">Digest: Four Important Data Type in C++</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-28T00:00:00-05:00" pubdate data-updated="true">Jun 28<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
<b>1.const的用法：</b><br />为什么使用const？采用符号常量写出的代码更容易维护；指针常常是边读边移动，而不是边写边移动；许多函数参数是只读不写的。const最常见用途是作为数组的界和switch分情况标号（也可以用枚举符代替）<br /><br />用法1：常量<br />取代了C中的宏定义，声明时必须进行初始化。const限制了常量的使用方式，并没有描述常量应该如何分配。如果编译器知道了某const的所有使用，它甚至可以不为该const分配空间。最简单的常见情况就是常量的值在编译时已知，而且不需要分配存储。（摘自《C++ Program Language》）用const声明的变量虽然增加了分配空间，但是可以保证类型安全。C标准中，const定义的常量是全局的。在C++中，const对象默认为定义它的文件的局部变量，那么把它定义在头文件中，也就意味着每个包含该头文件的源文件都有了自己的const变量，其名称和值都是一样的。<br /><br />用法2：指针和常量<br />使用指针时涉及到两个对象：该指针本身和被它所指的对象。将一个指针的声明用const“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，必须使用声明运算符*const。所以出现在 * 之前的const是作为基础类型的一部分：<br />char *const cp; //到char的const指针<br />char const *pc1; //到const char的指针<br />const char *pc2; //到const char的指针（后两个声明是等同的）<br />从右向左读的记忆方式：<br />cp is a const pointer to char.<br />pc2 is a pointer to const char.<br /><br />用法3：const修饰函数传入参数<br />将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。同理，将指针参数声明为const，函数将不修改由这个参数所指的对象。通常修饰指针参数和引用参数：<br />void Fun( const A *in); //修饰指针型传入参数<br />void Fun(const A &amp;in); //修饰引用型传入参数<br /><br />用法4：修饰函数返回值<br />可以阻止用户修改返回值。返回值也要相应的付给一个常量或常指针。<br /><br />用法5：const修饰成员函数<br />1、const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；2、const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的；3、const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。<br /><br /><br /><b>2.static的用法：</b><br />静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为0，使用时可以改变其值。静态变量或静态函数只有本文件内的代码才能访问它，它的名字在其它文件中不可见。<br /><br />用法1：函数内部声明的static变量，可作为对象间的一种通信机制<br />如果一局部变量被声明为static，那么将只有唯一的一个静态分配的对象，它被用于在该函数的所有调用中表示这个变量。这个对象将只在执行线程第一次到达它的定义使初始化。<br /><br />用法2：局部静态对象<br />对于局部静态对象，构造函数是在控制线程第一次通过该对象的定义时调用。在程序结束时，局部静态对象的析构函数将按照他们被构造的相反顺序逐一调用，没有规定确切时间。<br /><br />用法3：静态成员和静态成员函数<br />如果一个变量是类的一部分，但却不是该类的各个对象的一部分，它就被成为是一个static静态成员。一个static成员只有唯一的一份副本，而不像常规的非static成员那样在每个对象里各有一份副本。同理，一个需要访问类成员，而不需要针对特定对象去调用的函数，也被称为一个static成员函数。需要注意，类的静态成员函数只能访问类的静态成员（变量或函数）。<br /><br /><b>3.extern的用法：</b><br />extern可以声明其他文件内定义的变量。在一个程序里，一个对象只能定义一次，它可以有多个声明，但类型必须完全一样。如果定义在全局作用域或者名字空间作用域里某一个变量没有初始化，它会被按照默认方式初始化。<br /><br />将变量或函数声明成外部链接，即该变量或函数名在其它函数中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。在C++中，还可以指定使用另一语言链接，需要与特定的转换符一起使用。<br />extern “C” 声明语句<br />extern “C” { 声明语句块 }<br /><br />需要注意声明和定义之间的区别（from 《C++ Primer》）<br />extern int ival1; &nbsp; &nbsp; //it&#8217;s a&nbsp;declaration.<br />extern int ival2=10; &nbsp;//initializer, so it&#8217;s a definition.<br />double fica_rate; &nbsp; &nbsp; //no extern, so it&#8217;s a definition.<br />同一个程序中，有两个以上的文件含有上述对于同一个变量的任一种定义，都会导致多重定义链接错误。<br /><br /><br /><b>4.volatile的用法：</b><br />类型修正符（type-modifier），限定一个对象可被外部进程（操作系统、硬件或并发进程等）改变。volatile与变量连用，可以让变量被不同的线程访问和修改。常用于像中断处理程序之类的异步进程进行内存单元访问。声明时语法：<br />int volatile vInt;<br /><br />除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。特别注意：可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/25/network-simulator/">Network Simulator</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-25T00:00:00-05:00" pubdate data-updated="true">Jun 25<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
最近一直在鼓捣网络仿真软件，逐渐发现些开源的好处，大家都在整理资料，都在去努力完善一个项目。当这样的行为发生在某一群向着相同目标进发的专业人士身上，似乎惺惺相惜的感觉就更加强烈。当然，我还只能算作业余，逐渐把自己用到的链接添加在这里，应该比仅仅下载到本地的作用会更大。<br /><br />Useful references (order from more basic to more complex):<br /><br /><a href="http://www-sop.inria.fr/maestro/personnel/Eitan.Altman/COURS-NS/n3.pdf">NS Simulator for Beginners, lecture notes</a> This is a very good point to begin with.<br /><a href="http://wcc.iiita.ac.in/ns/nstutorial.pdf">Sandeep Gupta NS tutorial</a>&nbsp; Very simple and straightforward slides.<br /><a href="http://nile.wpi.edu/NS/">NS by Examples</a> Practical breakpoints to get involved. The comments are also useful if the current version of ns-2 cannot debug the original code.<br /><a href="http://www.isi.edu/nsnam/ns/tutorial/index.html">Marc Greis&#8217; Tutorial</a>&nbsp; This is the classic and most important tutorial. It has been fully recommend to MASTER the step-by-step exercises it describes, especially if you are going to change the NS2 code. The Ping Agent that he describes is very important to do it yourself, instead of simply downloading the c++ files and compiling it. Furthermore, refer to this post on the ns2 mailing list to know the additional steps required on the ping agent on the newest versions of NS2. (<a href="http://mailman.isi.edu/pipermail/ns-users/2006-January/053697.html">click</a>)<br /><a href="http://nsnam.isi.edu/nsnam/index.php/Main_Page">New NS wiki</a> There are lots of information which order in a more structured way.<br /><a href="http://www-sop.inria.fr/mistral/personnel/Eitan.Altman/ns.htm">NS Simulator Courses for Beginner</a> Although it has BEGINNER in the caption, the destination is to check the scripts. We can also refer to the /ns/tcl/ex and /ns/tcl/test directories of ns2 source tree.<br /><a href="http://www.isi.edu/nsnam/ns/ns-documentation.html">NS Manual</a> is used to peek the reference documentation.<br /><a href="http://140.116.72.80/%7Esmallko/ns2/NS_From%20China.rar">NS中文手册</a><br /><a href="http://masimum.dif.um.es/nsrt-howto/pdf/nsrt-howto.pdf">Implementing a New Manet Unicast Routing Protocol in NS2</a><br /><a href="http://icapeople.epfl.ch/aad/teaching/ns/ns-2-for-the-impatient.pdf">ns2 for the Impatient</a><br /><a href="http://info.iet.unipi.it/%7Ecng/ns2measure/manual-060529.pdf">ns2measure manual</a><br /><br /><br />Personal web pages: <br /><a href="http://140.116.72.80/%7Esmallko/ns2/ns2.htm">柯志亨教授的主页</a> has many useful references and video guidance.<br /><a href="http://tagus.inesc-id.pt/%7Epestrela/ns2/">Pedro Vale Estrela&#8217;s NS2 Page</a><br /><a href="http://personal.ee.surrey.ac.uk/Personal/L.Wood/ns/">Lloyd Wood&#8217;s NS2 Page</a></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/25/million-dollar-baby/">Million Dollar Baby</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-25T00:00:00-05:00" pubdate data-updated="true">Jun 25<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
和L的电话里说了好多。这样一部感动我的电影，让我有了想要写下些什么的冲动。<br /><br />电影中可用以回顾的东西太多，以至于我很难用其中的某一句话给电影在豆瓣里做一个标记——以前我总是习惯如此，拿自认为感触最深的一句话作为电影的总结，我曾经看过了。但百万宝贝不是。里面的很多话，用弗里德曼磁性的声音，演绎的犹如寓言：Winner is simply willing to do the things that loser won&#8217;t&#8230;&#8230;Boxing is about respect. Getting it for yourself, and taking it away from the other guy&#8230;&#8230;If there&#8217;s magic in boxing: it&#8217;s the magic of fighting battles beyond endurance, beyond cracked ribs, ruptured kidneys, and detached retinas&#8230;&#8230;<b>It&#8217;s the magic of risking everything for a dream that nobody sees but you</b>&#8230;&#8230;Frankie liked to say that boxing is an unnatural act that everything in boxing is backwards. Sometimes, best way to deliver a punch is step back. But step back too far, you ain&#8217;t fighting at all&#8230;&#8230;.Boxing is an unnatural act. Because everything in it is backwards. You wanna move to the left you don&#8217;t step left, you push on the right toe. To move right, you use your left toe. Instead of running from the pain, like a sane person would do, you step into it&#8230;&#8230;<br /><br />看过开头，如同monga，我料到这会是悲剧一出。很久以前看到的一句话分外贴切，我们是糖，甜到哀伤。maggie，剧中出场时还有月余就满32岁的小女人。微笑着，面对埃斯特伍德一次次冷血的拒绝。微笑着，把食客们吃剩的牛扒包进锡纸里，并笑着告诉老板要拿它回家喂小狗。微笑着，拿过弗里德曼手中破旧的拳击鞋和speed ball，说自己先借着，买了就还回来。微笑着，拿到两美元小费攒齐了买新speed ball的所有钱，然后欣喜的在体育用品店老板柜台上掏出一大堆硬币以及小额钞票，这是她给自己32岁买的生日礼物。当然，埃斯特伍德决定收她为徒时候，她笑得更加灿烂。以及每次打赢比赛，都笑得很傻，问埃斯特伍德，老板，我打的不错吧。<br /><br />当然，她也有不笑的时候。比如镜头几次切换到她回家的公车上。藏在宽大的套头衫里，她表情严峻的注视着窗外；或者正在一口水，一口剩牛排，吃着晚餐。在家的时候，拿一个小本子，细心地记下每一小笔收入，算着再过多久能买个speed ball，或者还要再攒多久，可以给妈妈和妹妹买套房子。还有在gym的时候，永远在专注的全力以赴。<br /><br />三位主角，独自一人时，幽怨而缓慢的吉他配乐。训练室里的荤笑话和一群粗人挑逗的笑声。拳击场旁观中的尖叫声。还有出现很多的，拳头打击沙袋或者speed ball的声音，短促而有力。所有的这些声响，叠加在一起，观看时候，就实实在在的堵在我胸口上。<br /><br />她的结局，似乎早已注定。专注和不知疲惫的奉献，成就了这个世界冠军；而纯真又不知自我保护，让她在这个险恶的世界里，从伤痕累累最终倒下不起。看到最后才发觉，原来见方的拳击台，只是作者表达思想而戏剧化出来的一个舞台而已。光阴在此，演绎的更加绚烂而摄人心魄。一个人从降生开始，生命就成了无数的随机事件不断累积之和，加之事物与生俱来的两面性，很难讲如何才能够善始善终。言行无愧于本心，尽力而无愧于时间，倒是可以做到且要时刻警醒达到的。<br /><br />弗里德曼在影片最后宽慰埃斯特伍德的一段话：Maggie walked through that door with nothing but guts. No chance in the world of being what she needed to be. A year and a half later, she&#8217;s fighting for the championship of the world. You did that. People die every day, Frankie. Mopping floors, washing dishes. And you know what their last thought is?&#8211;&#8220;I never got my shot.&#8221; Because of you, Maggie got her shot. If she dies today, you know what her last thought will be?&#8211;&#8220;I think I did all right. I know I could rest with that.&#8221;</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/19/recent-update/">Recent Update</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-19T00:00:00-05:00" pubdate data-updated="true">Jun 19<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
一周的时间，生活改变了不少。可以按照自己的时间睡觉、起床。也可以躺在床上给小同学打电话。除了电话，一直不说话，感觉也还不错:) 做了一次西红柿牛腩，味道最终很像烤牛肉干，可以算作失之东隅收之桑榆么。出门跑步，把钥匙放在隔墙上，结果掉到了空心的墙壁中，钓了整整一晚。世界杯开幕了，兴趣一般，也许是听不到母语解说的缘故，不能嘲笑解说时而的短路，于是比赛也索然了很多。<br /><br />周三见了老师，笑眯眯的样子，应该是蛮好相处。组里的同学，接触较多的两个印度人，暂时还算友好。测量增益的实验，这周没有做成，下周一希望能用少量的时间完成。折腾了两天，终于自己安装好了cygwin和ns-2，竟然终究是版本兼容的问题，还枉费我卸了装、装了卸的鼓捣了半天gcc……上个学期dsp课程设计，我学会了应该如何解读完全陌生的matlab代码，这次学会了如何在感觉上乱七八糟的英文google信息中找到自己想要的东西，也算是有所得的。实验先从SISO的状况开始，仿真一下手中已有的几个算法，归一化所有的自变量，之后希望自己能给出一个MIMO的测试结果，这样结合实际测量的一些初步结果，就可以攒一篇论文出来了。<br /><br />效率高些。也希望这段时间快点过。我想回家了。 想她了。</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/11/good-luck/">Good Luck:)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-11T00:00:00-05:00" pubdate data-updated="true">Jun 11<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
Cherubic cutie, you will be alright. I will bless for you all day long&#8230;</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/03/missing/">Missing</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-03T00:00:00-05:00" pubdate data-updated="true">Jun 3<span>rd</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
其实什么事情都没有发生，日子就如往常般平淡着过着。可就是想你，无法抑制，不能自已。</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/02/raining-and-waiting/">Raining and Waiting</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-02T00:00:00-05:00" pubdate data-updated="true">Jun 2<span>nd</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
austin的雨水总是很迷人。身处一个古香古色的自习室里，又是独自一人占据这个大屋子。桌子、百叶窗、窗掾的暗红色木质感配合淡黄色的灯光，让人感觉安逸。雨水就这样一阵阵间断而急促的敲打着玻璃。之前下雨时在宿舍，总会感慨，有个屋檐可以躲避雨水而安然入睡，真好。现在的感慨是，有个屋檐，可以静听雨声，读读书写写字，真好。总之，真好。<br /><br />6月12日老师才会从外地抵达学校。自己的研究方向最终的确定，也需要等到那会儿。然后，又是一个多月后，才能回国，才能见到lan。又是一个漫长的等待。我所能做的，就是按时做好自己份内的事情。然后每日掰着手指数上一遍。想念是很玄的东西，无论如何形容，都无法尽情展述。</div>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/13/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/11/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/10/09/lte-reading-excerpt/">LTE reading excerpt</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/30/johnsons-algorithm/">All-pairs shortest path</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/15/more-freedom-in-doing-things/">More freedom in doing things</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/10/reading-note-of-sicp-4/">Reading note of SICP (4)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/08/reading-note-of-sicp-3/">Reading note of SICP (3)</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  <a href="https://github.com/creasyw">Qiong Wu</a> &copy;2009-2013 &mdash;
  <span class="credit">Thanks to <a href="http://ayyang.com">Alex Yang</a>, <a href="http://octopress.org/">Octopress</a> and <a href="https://github.com/">Github</a>.</span><br>
  send me an email 
<script type="text/javascript">
var emailriddlerarray=[99,114,101,97,115,121,119,117,113,105,111,110,103,64,103,109,97,105,108,46,99,111,109]
var encryptedemail_id82='' //variable to contain encrypted email 
for (var i=0; i<emailriddlerarray.length; i++)
 encryptedemail_id82+=String.fromCharCode(emailriddlerarray[i])
 document.write('<a href="mailto:'+encryptedemail_id82+'"><img src="/img/email.png" alt="Qiong" /></a>')
</script>
</p>
</footer>
</body>
</html>
