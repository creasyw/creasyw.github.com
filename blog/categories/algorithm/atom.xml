<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Qiong Wu]]></title>
  <link href="http://creasyw.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://creasyw.github.io/"/>
  <updated>2013-11-18T23:00:29-06:00</updated>
  <id>http://creasyw.github.io/</id>
  <author>
    <name><![CDATA[Qiong Wu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Find the longest chain under 1M with Collatz Conjecture condition]]></title>
    <link href="http://creasyw.github.io/blog/2011/09/27/find-longest-chain-under-collatz/"/>
    <updated>2011-09-27T00:00:00-05:00</updated>
    <id>http://creasyw.github.io/blog/2011/09/27/find-longest-chain-under-collatz</id>
    <content type="html"><![CDATA[<div class="post">
It is the #14 problem in <a href="http://projecteuler.net/">Project Euler</a>.<br />In general, the Collatz conjecture has two main properties:<br />1. no infinite trajectory occurs;<br />2. no cycle occurs.<br /><br />The basic algorithm is quite straightforward. It just follows the instruction of Collatz Conjecture, which are n = n/2 if n is even, and n = 3*n+1 if n is odd. To accelerate the calculation, I also implemented a hash map, which could be retrieve theoretically in constant time O(1), and use the iteration number as the key in this map and the overall steps towards 1 as the value of that key. Under this situation, whenever a new node is found, it will be added into the map, and continue the computation until it reaches some key which has already stored in the map. That is, the route is undetermined before the calculation, but every number only needs to calculate once.<br /><br />The first problem I met is exactly the problem "<a href="http://stackoverflow.com/questions/6825146/why-am-i-getting-an-outofmemoryerror-in-java/7561025#7561025">Why am I getting an OutOfMemoryError trouble in Java?</a>" described in the StackOverflow. When the program reaches 113383, all of the heap space will be consumed. As I looked up in the internet, all solutions point to how to increase the heap space for Java. While, as I narrowed down the bug to the innermost loop and print out every relevant variable, the bug finally turned out to be the overflow of integer data type. Just change it into long would solve this problem.<br /><br />The second problem had the same symptom but with a much bigger number. When I print out every variable this time, nothing seemed wrong. But if we check the memory usage in run-time, all of the memory had been consumed by the hash map as some number will have extremely long chain towards 1, part of which are far beyond the range of 1000000. The scale is over 1.5 million items in hash map to achieve 725343. The solution is that the program only record number under 1 million, which are within the searching range and also most likely to be hit.<br /><br /><br />Solution discussions: <a href="http://stackoverflow.com/questions/2643260/project-euler-question-14-collatz-problem">[1]</a> (discussion in StackOverflow), <a href="http://lanzkron.wordpress.com/2010/01/18/yet-another-meaningless-javascript-benchmark/">[2]</a> (in JavaScript), <a href="http://lanzkron.wordpress.com/2010/06/02/optimizing-collatz-for-klutzes/">[3]</a> (optimization), <a href="http://blog.functionalfun.net/2008/07/project-euler-problem-14-hailstone.html">[4]</a> (in C++), <a href="http://sandrotosi.blogspot.com/2010/03/project-euler-problem-14.html">[5]</a> (in Python). By the way, <a href="http://stackoverflow.com/questions/235047/why-do-i-get-an-outofmemoryerror-when-inserting-50-000-objects-into-hashmap">here</a> is the discussion about looking up memory usage during run time in Java--it helps me find the 2nd bug. Finally, my solution is in <a href="https://github.com/creasyw/learning/blob/master/puzzles/Q011To015.java">one of my Github repositories</a>.</div>
]]></content>
  </entry>
  
</feed>
