
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>some basic C/C++ questions - Qiong Wu</title>
  <meta name="author" content="Qiong Wu">

  
  <meta name="description" content="1) What are some of the main differences between a linked list and an array?Arrays are faster in access than a link list for random access with &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://creasyw.github.io/blog/2011/03/04/some-basic-cc-questions/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="./atom.xml" rel="alternate" title="Qiong Wu" type="application/atom+xml">
  
  <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  
  
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Qiong Wu</a></h1>
  <!--
  
    <h2>A blogging framework for hackers.</h2>
  
  -->
</hgroup>
</header>
  <nav role="navigation"><!--
<ul class="subscription" data-subscription="rss">
  <li><a href="./atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:creasyw.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

-->

<ul class="main-navigation">
  <!--<li><a class="yellow" href="/">Hello</a></li>-->
  <li><a class="github" href="/blog/archives/">Blog</a></li>
  <li><a class="github" href="/tags">Tags</a></li>
  <li><a class="github" href="http://www.github.com/creasyw">Github</a></li>
  <li><a class="github" href="https://twitter.com/creasywuqiong">Twitter</a></li>
  <li><a class="github" href="/rss">RSS</a></li>
</ul>


</nav>
  <div id="main">
    <div id="content">
      <article>
  <header>
    
      <h1 class="entry-title">Some Basic C/C++ Questions</h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-04T00:00:00-05:00" pubdate data-updated="true">Mar 4<span>th</span>, 2011</time>
        
      </p>
    
  </header>


<div class="entry-content"><div class='post'>
<span id="internal-source-marker_0.4999975798251227" style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">1) What are some of the main differences between a linked list and an array?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are faster in access than a link list for random access with index.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are not dynamic while a link list is.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are easier to sort than a link list.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The elements of link list can be deleted/inserted while arrays cannot.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays occupy the same block of memory, while a link list is distributed.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Array objects are automatically created by a compiler, while link lists are not.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are part of most compilers, while link lists are not.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Arrays are syntactically simple to read.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">2) What are the differences between struct, class and union?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Struct,  class and union all contain data members and methods. However, a struct  and union have their member’s public by default, while the class  members are private by default. Also, a struct cannot contain an  instance of itself. A union cannot be used as a base class in  inheritance. None of a union&#8217;s data members can be declared static and  none of its functions can be virtual.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">3) What are virtual functions?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Virtual  functions are functions whose behavior is known at runtime rather than  at compile time. Due to this behavior, it can be said that virtual  functions implement Polymorphism. In other words, preceding a function  name with virtual in the base class means that that function is intended  to be re-implemented (overridden) in the sub-class.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">4) Explain the mechanism of virtual functions and virtual function tables.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Whenever  a class member function is declared as virtual, the compiler creates a  virtual table in memory which contains all function pointers that are  declared as virtual in that class. This enables run time polymorphism  (i.e. finding out the desired function at run time). Virtual function  tables also have an additional pointer in the object to the vtable. As  this additional pointer and the vtable increases the size of the object,  a class designer needs to be judicious about declaring functions  virtual. The sequence of events upon calling a method on the base object  pointer is:</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Get vtable pointer (this vtable pointer points to the beginning of the vtable).</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Get the function pointers in the vtable using offset.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Invoke the function indirectly through the vtable pointer.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">5) Given a singly linked list and a pointer to a certain node in the list, how would you delete that node in constant time?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">First  of all, check if this node is the last node in the list. If not, copy  the contents of the next node to the current node, and delete the next  node.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">6) What are recursive functions? What are the advantages and disadvantages of recursive algorithms?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  function that calls itself repeatedly, satisfying some condition, is  called a Recursive Function. In my point of view, the recursive  functions should be avioded at most of the time via the &#8220;while&#8221; loop  sentence. However, on the other hand, some problems inherently are  better suited for recursion, such as Fibonacci series generation.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Some  advantages of recursive algorithms are: concise in terms of source  code; and looking more elegant. The disadvantages of recursion include:  requiring more of stack than non-recursive algorithms, due to several  activation stacks for each call of the function; and correcting or  testing recursive functions would require a lot of careful thinking.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">7) What leads to code-bloating in C++?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Inline  functions and templates, if not used properly, may lead to code  bloating. Multiple Inheritance may also lead to code bloating (this is  because the sub classes will end up getting members from all the base  classes even if only few members will suffice).</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Inline  is great. Reasons: They look like functions, they act like functions,  they&#8217;re ever so much better than macros (Whenever you write a macro, you  have to remember to parenthesize all the arguments in the macro body.  Otherwise you can run into trouble when somebody calls the macro with an  expression. On the contrary, inline funtions do not have that kind of  troubles), and you can call them without having to incur the overhead of  a function call. Moreover, as inlining a function, it may enable  compilers to perform context-specific optimizations on the body of the  function. Most compilers never perform such optimizations on &#8220;outlined&#8221;  function calls.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">However,  the idea behind an inline function is to replace each call of that  function with its code body, which is likely to increase the size of  your object code. On machines with limited memory, overzealous inlining  can give rise to programs that are too big for the available space. Even  with virtual memory, inline-induced code bloat can lead to additional  paging, a reduced instruction cache hit rate, and the performance  penalties that accompany these things.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Solution:  Initially, don&#8217;t inline anything, or at least limit your inlining to  those functions that must be inline (eg. functions defined inside a  class which are implicitly declared inline) or are truly trivial (such  as Person::age). By employing inlines cautiously, you facilitate your  use of a debugger, but you also put inlining in its proper place: as a  hand-applied optimization. Don&#8217;t forget the empirically determined rule  of 80-20, which states that a typical program spends 80% of its time  executing only 20% of its code. It&#8217;s an important rule, because it  reminds you that your goal as a software developer is to identify the  20% of your code that can increase your program&#8217;s overall performance.  You can inline and otherwise tweak your functions until the cows come  home, but it&#8217;s wasted effort unless you&#8217;re focusing on the right  functions.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">8) What are references in C++? Why do you need them when you have pointers?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Reference  variables are internally implemented as a pointer; it’s just that  programmers can&#8217;t use it the way they use pointers. As a side note, a  reference must refer to some object at all times, but a pointer can  point to NULL. In this way, references can be more efficient when you  know that you&#8217;ll always have an object to point to, because you don&#8217;t  have to check against NULL.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">9)  How do you do dynamic memory allocation in C applications? List  advantages and disadvantages of dynamic memory allocation vs. static  memory allocation.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">In C, malloc, calloc and realloc are used to allocate memory dynamically. In C++, new(), is usually used to allocate objects.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Advantage  is that memory is allocated on an as-needed basis, which helps remove  the inefficiencies inherent to static memory allocation, that is when  the amount of memory needed is not known at compile time and one has to  make a guess.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Disadvantages:  1) dynamic memory allocation is slower than static memory allocation,  because dynamic memory allocation happens in the heap area; 2) dynamic  memory needs to be carefully deleted after use, because they are created  in non-contiguous area of memory segment, and if not properly handled,  the operations would cause memory fragmentation; 3) dynamic memory  allocation causes contention between threads, so it degrades performance  when it happens in a thread.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">10) What are constructors and destructors?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Constructors and destructors are provisions for initialization and cleanup of objects.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  constructor is a special member function with the same name as the  Class. It is invoked automatically when the object is created. It  usually contains initialization code for member variables and allocation  of memory. There can be multiple overloaded constructors, with  different input arguments, used to initialize the object in a variety of  ways.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  destructor is a special member function that is called just before an  object is destroyed. For example, when the object variable goes out of  scope. It is used to perform cleanup. There can be only one destructor.  Its name is ‘~’ followed by the class name.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">11) What happens if an error occurs in a constructor or destructor?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Constructors  don&#8217;t have a return type, so it&#8217;s not possible to use error codes. The  best way to signal constructor failure is therefore to throw an  exception. However, keep in mind that the memory for the object itself  is released, and the destructors for all sub-objects (i.e. members and  base classes) whose constructors have successfully run to completion  will be called, which will consquently cause memory leak by the object  pointer.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">12) Differentiate between a copy constructor and an assignment operator.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  copy constructor is used to copy an object to a newly created object.  This is used during initialization and not during ordinary assignment.  The copy constructor is invoked whenever a new object is created and  initialized to an existing object of the same kind.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">In  other words, the assignment operator handles assigning one object to  another of the same class. If a statement creates a new object it is  using initialization. If it alters the value of an existing object it is  assignment.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">13) What are virtual destructors?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Destructor  implemented by declaring a base class’s destructor with the keyword  virtual is called a virtual destructor. A virtual destructor ensures  that, when delete is applied to a base class pointer or reference, it  calls the destructor implemented in the derived class, if an  implementation exists.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Let’s  take the simplest polymorphic relation: A - base class, B - class  derived from A. If we&#8217;ve got a pointer (or reference) to class A, but  under the hood it is an object of type B, and we&#8217;re trying to delete the  object, declaration of virtual destructor in class A ensures that the  destructor of class B will be called.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">B* b = new B;</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A* a = b //due to polymorphism!</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">delete a; // both A and B destructors are called.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">14)  What is multiple inheritance? What are the potential pitfalls of  multiple inheritance? How would you avoid multiple inheritance?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Deriving  a class from more than one direct base class is called multiple  inheritance. Note that the order of derivation is relevant only to  determine the order of default initialization by constructors and  cleanup by destructors.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Potential  pitfalls of Multiple Inheritance are: 1) Ambiguity; 2) slow; 3) The  “Common Ancestor” problem: For example, if class B and class C derived  from class A and if class D derived from class B and class C, then class  D will have 2 copies of class A that might lead to inconsistency, as  the class doesn&#8217;t know which copy it is viewing.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">15) What is exception handling? What are the advantages of exception handling?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Exceptions  are an alternative to function return values. The big differences are:  1) Exceptions cannot be ignored. They must be caught or the app will  crash. It is a way of forcing the caller of a function to deal with an  exceptional condition. 2) It is also an improvement over return values,  because you can put all possible values of your return type to good use,  instead of having to dedicate one or more values as the &#8220;invalid&#8221;  value. 3) In addition, exceptions allow you to jump out of deeply nested  function calls conveniently, avoiding a lot of return type checking and  conditional statements.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">16) What is the difference between new()/delete() and malloc()/free ()?</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  main difference is that malloc() and free() don&#8217;t know anything about  constructors and destructors, where as new and delete do. The following  lists the main differences: 1) new automatically computes the size of  the data object. In malloc you would have to use the sizeof operator. 2)  new automatically returns the correct pointer type. In malloc you would  have to use a type cast. 3) with new you can initialize the object  while creating the object. 4) new and delete can be overloaded. 5) It&#8217;s  safe to delete a NULL pointer, but you&#8217;ll get core dump to free a NULL  pointer.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">17) Describe different types of polymorphism available in C++.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">1.  Compile time polymorphism; 2. Runtime Polymorphism. Operator  overloading and Function Overloading are the examples for compile time  polymorphism. Using Virtual Functions we will achieve run time  polymorphism.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Computer Network</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 11pt; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  Internet Protocol (IP) is a key part of the mechanism for transferring  data across the internet. Information is broken into small packets, and  the IP is responsible for relaying and routing them around the system by  identifying and locating hosts. The current version is IPv4, and  because it is made up in sets of 32 bits, it is limited to having just  under 4.3 billion addresses. It seems like a lot but they are almost all  used up.</span></div>
</div>

</article>

    </div>
  </div>
  <footer role="contentinfo"><p>
  <a href="https://github.com/creasyw">Qiong Wu</a> &copy;2009-2013 &mdash;
  <span class="credit">Thanks to <a href="http://ayyang.com">Alex Yang</a>, <a href="http://octopress.org/">Octopress</a> and <a href="https://github.com/">Github</a>.</span><br>
  send me an email 
<script type="text/javascript">
var emailriddlerarray=[99,114,101,97,115,121,119,117,113,105,111,110,103,64,103,109,97,105,108,46,99,111,109]
var encryptedemail_id82='' //variable to contain encrypted email 
for (var i=0; i<emailriddlerarray.length; i++)
 encryptedemail_id82+=String.fromCharCode(emailriddlerarray[i])
 document.write('<a href="mailto:'+encryptedemail_id82+'"><img src="/img/email.png" alt="Qiong" /></a>')
</script>
</p>
</footer>
</body>
</html>
